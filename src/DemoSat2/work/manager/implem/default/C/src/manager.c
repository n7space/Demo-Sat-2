/* Body file for function Manager
 * Generated by TASTE (kazoo/templates/skeletons/c-body/function.tmplt)
 * You can edit this file, it will not be overwritten

    !! IMPORTANT                                                        !!
    !! When you modify your design (interface view), you must update    !!
    !! the procedures corresponding to the provided interfaces in this  !!
    !! file. The up-to-date signatures can be found in the .ads file.   !!
*/
#include "manager.h"
#include <math.h>

static volatile asn1SccTMode manager_mode = TMode_m_initializing;
static volatile asn1SccSunSensor manager_sunSensorAfec;
static asn1SccSunSensorConfig manager_sunSensorConfig = {
    .mAfecConfig = {
        .mAfecInstance = AfecHwas_Instance_afecHwas_Instance_Afec0,
        .mStartupTime = 15,
        .mPrescalerValue = 255,
    },
    .mChannel = 8,
};
static volatile asn1SccPropulsion manager_propulsion;
const asn1SccPropulsionConfig manager_propulsionConfig = {.arr =
                                                              {
                                                                  {
                                                                      .mPortConfig = PioHwas_Port_pioHwas_Port_B,
                                                                      .mPinConfig = 3,
                                                                      .mDirectionConfig = PioHwas_Direction_pioHwas_Direction_Output,
                                                                      .mControlConfig = PioHwas_Control_pioHwas_Control_Pio,
                                                                  },
                                                                  {
                                                                      .mPortConfig = PioHwas_Port_pioHwas_Port_B,
                                                                      .mPinConfig = 2,
                                                                      .mDirectionConfig = PioHwas_Direction_pioHwas_Direction_Output,
                                                                      .mControlConfig = PioHwas_Control_pioHwas_Control_Pio,
                                                                  },
                                                                  {
                                                                      .mPortConfig = PioHwas_Port_pioHwas_Port_B,
                                                                      .mPinConfig = 13,
                                                                      .mDirectionConfig = PioHwas_Direction_pioHwas_Direction_Output,
                                                                      .mControlConfig = PioHwas_Control_pioHwas_Control_Pio,
                                                                  },
                                                                  {
                                                                      .mPortConfig = PioHwas_Port_pioHwas_Port_D,
                                                                      .mPinConfig = 24,
                                                                      .mDirectionConfig = PioHwas_Direction_pioHwas_Direction_Output,
                                                                      .mControlConfig = PioHwas_Control_pioHwas_Control_Pio,
                                                                  },
                                                              }};

static volatile asn1SccTObjectDetectionReport manager_objectDetectionReport = {
    .position = 0.0f,
    .distance = 0.0f,
    .status = TValidityStatus_vs_nil};
static volatile asn1SccTHouseKeepingReport_propulsion manager_propulsionReport = {
    .arr = {0.0f, 0.0f, 0.0f, 0.0f}};
static volatile asn1SccTSunMonitoringReport manager_luminanceReport = {
    .luminance = 0.0f,
    .status = TValidityStatus_vs_nil};

static volatile asn1SccTLuminance manager_luminanceThreshold = 0.0f;
static volatile asn1SccTDistance manager_distanceThreshold = 0.0f;
static asn1SccTEnabled ENABLED = true;
static asn1SccTEnabled DISABLED = false;
static volatile asn1SccTEnabled manager_debugEnabled = false;

static void initializeHw()
{
   manager_RI_SunSensor_InitSunSensorCmd_Pi(&manager_sunSensorConfig, &manager_sunSensorAfec);
   manager_RI_Propulsion_InitPropulsionCmd_Pi(&manager_propulsion, &manager_propulsionConfig);
}

static void reportHk()
{
   asn1SccTHouseKeepingReport report;
   memset(&report, 0, sizeof(asn1SccTHouseKeepingReport));
   report.mode = manager_mode;
   report.objectDetection = manager_objectDetectionReport;
   report.propulsion = manager_propulsionReport;
   report.luminance = manager_luminanceReport;
   manager_RI_hk(&report);
}

static void reportSuccess(asn1SccTCID id)
{
   asn1SccTTM tm;
   memset(&tm, 0, sizeof(asn1SccTTM));
   tm.kind = TTM_tm_executed_PRESENT;
   tm.u.tm_executed.id = id;
   manager_RI_tm(&tm);
}

static void reportFailure(asn1SccTCID id, asn1SccTFailureReason reason)
{
   asn1SccTTM tm;
   memset(&tm, 0, sizeof(asn1SccTTM));
   tm.kind = TTM_tm_failed_PRESENT;
   tm.u.tm_failed.id = id;
   tm.u.tm_failed.reason = reason;
   manager_RI_tm(&tm);
}

static void reportMode(asn1SccTCID id)
{
   asn1SccTTM tm;
   memset(&tm, 0, sizeof(asn1SccTTM));
   tm.kind = TTM_tm_modeChanged_PRESENT;
   tm.u.tm_modeChanged.id = id;
   tm.u.tm_modeChanged.mode = manager_mode;
   manager_RI_tm(&tm);
}

static asn1SccPropulsion_ThrusterState toThrusterState(const float value)
{
   if (value >= 0.75f)
   {
      return Propulsion_ThrusterState_propulsion_ThrusterState_On;
   }
   else if (value >= 0.5f)
   {
      return Propulsion_ThrusterState_propulsion_ThrusterState_BlinkHigh;
   }
   else if (value >= 0.25f)
   {
      return Propulsion_ThrusterState_propulsion_ThrusterState_BlinkLow;
   }
   else
   {
      return Propulsion_ThrusterState_propulsion_ThrusterState_Off;
   }
}

static void setThruster(const uint32_t index, const float power) {
   manager_propulsionReport.arr[index] = power;
   asn1SccPropulsionThrusterIndex thruster = index;
   asn1SccPropulsion_ThrusterState state = toThrusterState(power);
   manager_RI_Propulsion_ChangeStateCmd_Pi(&thruster, &state);
}

static void disablePropulsion()
{
   setThruster(0, 0.0f);
   setThruster(1, 0.0f);
   setThruster(2, 0.0f);
   setThruster(3, 0.0f);
 }

static void enterIdle(asn1SccTCID id)
{
   manager_mode = TMode_m_idle;
   reportMode(id);
   disablePropulsion();
   manager_RI_ObjectDetection_SetEnabled(&DISABLED);
}

static void enterPassive(asn1SccTCID id)
{
   manager_mode = TMode_m_passive;
   reportMode(id);
   disablePropulsion();
   manager_RI_ObjectDetection_SetEnabled(&ENABLED);
}

static void enterActive(asn1SccTCID id)
{
   manager_mode = TMode_m_active;
   reportMode(id);
   manager_RI_ObjectDetection_SetEnabled(&ENABLED);
}

static void enterSafe(asn1SccTCID id)
{
   manager_mode = TMode_m_safe;
   reportMode(id);
   disablePropulsion();
   manager_RI_ObjectDetection_SetEnabled(&DISABLED);
}

static float alignmentFactor(const float position, const float reference, const float margin)
{
   const float distance = fabs(position - reference);
   if (distance < margin)
   {
      return (margin - distance) / margin;
   }
   else
   {
      return 0.0f;
   }
}

void manager_PI_pps_ss(void) {
   switch (manager_mode)
   {
   case TMode_m_initializing:
      // NOP
      break;
   case TMode_m_idle:
      manager_RI_SunSensor_RequestDataCmd_Pi(&manager_sunSensorAfec);
      break;
   case TMode_m_passive:
      manager_RI_SunSensor_RequestDataCmd_Pi(&manager_sunSensorAfec);
      break;
   case TMode_m_active:
      manager_RI_SunSensor_RequestDataCmd_Pi(&manager_sunSensorAfec);
      break;
   case TMode_m_safe:
      // NOP
      break;
   }
}

void manager_PI_pps_hk(void)
{
   switch (manager_mode)
   {
   case TMode_m_initializing:
      initializeHw();
      enterIdle(0);
      break;
   case TMode_m_idle:
      reportHk();
      break;
   case TMode_m_passive:
      reportHk();
      break;
   case TMode_m_active:
      reportHk();
      break;
   case TMode_m_safe:
      // NOP
      break;
   }
}

void manager_startup(void)
{
}

void manager_PI_ObjectDetection_Report(const asn1SccTObjectDetectionReport *IN_report)
{
   manager_objectDetectionReport = *IN_report;
   if (manager_mode != TMode_m_active)
   {
      return;
   }
   if (manager_objectDetectionReport.status != TValidityStatus_vs_ok)
   {
      return;
   }
   if (manager_objectDetectionReport.distance < manager_distanceThreshold)
   {
      setThruster(0, alignmentFactor(manager_objectDetectionReport.position, -0.75f, 0.5f));
      setThruster(1, alignmentFactor(manager_objectDetectionReport.position, -0.25f, 0.5f));
      setThruster(2, alignmentFactor(manager_objectDetectionReport.position, 0.25f, 0.5f));
      setThruster(3, alignmentFactor(manager_objectDetectionReport.position, 0.75f, 0.5f));
   }
   else
   {
      disablePropulsion();
   }
}

void manager_PI_SunSensorReturn_ReturnDataCmd_Ri(const asn1SccConversionData *IN_choutput)
{
   manager_luminanceReport.luminance = 101 - ((float)IN_choutput->mValue);
   manager_luminanceReport.status = TValidityStatus_vs_ok;
   if (manager_luminanceReport.luminance >= manager_luminanceThreshold) {
      return;
   }
   switch (manager_mode)
      {
      case TMode_m_passive:
         enterSafe(0);
      case TMode_m_active:
         enterSafe(0);
         break;
      default:
         break;
      }
}

void manager_PI_tc(const asn1SccTTC *IN_request)
{
   switch (IN_request->kind)
   {
   case TTC_tc_goToIdle_PRESENT:
      switch (manager_mode)
      {
      case TMode_m_idle:
         reportFailure(IN_request->u.tc_goToIdle.id, TFailureReason_fr_incorrectState);
         break;
      case TMode_m_passive:
         reportSuccess(IN_request->u.tc_goToIdle.id);
         enterIdle(IN_request->u.tc_goToIdle.id);
         break;
      case TMode_m_active:
         reportFailure(IN_request->u.tc_goToIdle.id, TFailureReason_fr_incorrectState);
         break;
      case TMode_m_safe:
         reportSuccess(IN_request->u.tc_goToIdle.id);
         enterIdle(IN_request->u.tc_goToIdle.id);
         break;
      }
      break;
   case TTC_tc_goToPassive_PRESENT:
      switch (manager_mode)
      {
      case TMode_m_idle:
         reportSuccess(IN_request->u.tc_goToPassive.id);
         manager_luminanceThreshold = IN_request->u.tc_goToPassive.sunThreshold;
         enterPassive(IN_request->u.tc_goToPassive.id);
         break;
      case TMode_m_passive:
         reportFailure(IN_request->u.tc_goToPassive.id, TFailureReason_fr_incorrectState);
         break;
      case TMode_m_active:
         reportSuccess(IN_request->u.tc_goToPassive.id);
         manager_luminanceThreshold = IN_request->u.tc_goToPassive.sunThreshold;
         enterPassive(IN_request->u.tc_goToPassive.id);
         break;
      case TMode_m_safe:
         reportFailure(IN_request->u.tc_goToPassive.id, TFailureReason_fr_incorrectState);
         break;
      }
      break;
   case TTC_tc_goToActive_PRESENT:
      switch (manager_mode)
      {
      case TMode_m_idle:
         reportFailure(IN_request->u.tc_goToActive.id, TFailureReason_fr_incorrectState);
         break;
      case TMode_m_passive:
         reportSuccess(IN_request->u.tc_goToActive.id);
         manager_distanceThreshold = IN_request->u.tc_goToActive.distanceThreshold;
         enterActive(IN_request->u.tc_goToActive.id);
         break;
      case TMode_m_active:
         reportFailure(IN_request->u.tc_goToActive.id, TFailureReason_fr_incorrectState);
         break;
      case TMode_m_safe:
         reportFailure(IN_request->u.tc_goToActive.id, TFailureReason_fr_incorrectState);
         break;
      }
      break;
   case TTC_tc_debug_PRESENT:
      manager_debugEnabled = IN_request->u.tc_debug.enabled;
      manager_RI_Debug_SetEnabled(&manager_debugEnabled);
      reportSuccess(IN_request->u.tc_debug.id);
      break;
   }
}
