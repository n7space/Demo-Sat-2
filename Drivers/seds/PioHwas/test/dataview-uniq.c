/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>

#include "asn1crt_encoding.h"
#include "asn1crt_encoding_uper.h"
#include "asn1crt_encoding_acn.h"

#include "dataview-uniq.h"



flag asn1SccDestinationAddress_Equal(const asn1SccDestinationAddress* pVal1, const asn1SccDestinationAddress* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void asn1SccDestinationAddress_Initialize(asn1SccDestinationAddress* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccDestinationAddress_IsConstraintValid(const asn1SccDestinationAddress* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 4294967295UL);
    *pErrCode = ret ? 0 :  ERR_DESTINATIONADDRESS; 

	return ret;
}

flag asn1SccDestinationAddress_Encode(const asn1SccDestinationAddress* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccDestinationAddress_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccDestinationAddress_Decode(asn1SccDestinationAddress* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_DESTINATIONADDRESS;

	return ret  && asn1SccDestinationAddress_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccDestinationAddress_ACN_Encode(const asn1SccDestinationAddress* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccDestinationAddress_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccDestinationAddress_ACN_Decode(asn1SccDestinationAddress* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_DESTINATIONADDRESS;

    return ret && asn1SccDestinationAddress_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccSourceAddress_Equal(const asn1SccSourceAddress* pVal1, const asn1SccSourceAddress* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void asn1SccSourceAddress_Initialize(asn1SccSourceAddress* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccSourceAddress_IsConstraintValid(const asn1SccSourceAddress* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 4294967295UL);
    *pErrCode = ret ? 0 :  ERR_SOURCEADDRESS; 

	return ret;
}

flag asn1SccSourceAddress_Encode(const asn1SccSourceAddress* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccSourceAddress_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccSourceAddress_Decode(asn1SccSourceAddress* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_SOURCEADDRESS;

	return ret  && asn1SccSourceAddress_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccSourceAddress_ACN_Encode(const asn1SccSourceAddress* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccSourceAddress_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccSourceAddress_ACN_Decode(asn1SccSourceAddress* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_SOURCEADDRESS;

    return ret && asn1SccSourceAddress_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccWord_Equal(const asn1SccWord* pVal1, const asn1SccWord* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void asn1SccWord_Initialize(asn1SccWord* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccWord_IsConstraintValid(const asn1SccWord* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 4294967295UL);
    *pErrCode = ret ? 0 :  ERR_WORD; 

	return ret;
}

flag asn1SccWord_Encode(const asn1SccWord* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccWord_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccWord_Decode(asn1SccWord* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_WORD;

	return ret  && asn1SccWord_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccWord_ACN_Encode(const asn1SccWord* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccWord_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccWord_ACN_Decode(asn1SccWord* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_WORD;

    return ret && asn1SccWord_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccWordMask_Equal(const asn1SccWordMask* pVal1, const asn1SccWordMask* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void asn1SccWordMask_Initialize(asn1SccWordMask* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccWordMask_IsConstraintValid(const asn1SccWordMask* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 4294967295UL);
    *pErrCode = ret ? 0 :  ERR_WORDMASK; 

	return ret;
}

flag asn1SccWordMask_Encode(const asn1SccWordMask* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccWordMask_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccWordMask_Decode(asn1SccWordMask* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_WORDMASK;

	return ret  && asn1SccWordMask_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccWordMask_ACN_Encode(const asn1SccWordMask* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccWordMask_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccWordMask_ACN_Decode(asn1SccWordMask* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_WORDMASK;

    return ret && asn1SccWordMask_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccPioHwas_mPortAddress_Equal(const asn1SccPioHwas_mPortAddress* pVal1, const asn1SccPioHwas_mPortAddress* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccPioHwas_mPin_Equal(const asn1SccPioHwas_mPin* pVal1, const asn1SccPioHwas_mPin* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccPioHwas_mPortPerAddress_Equal(const asn1SccPioHwas_mPortPerAddress* pVal1, const asn1SccPioHwas_mPortPerAddress* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccPioHwas_mPortOerAddress_Equal(const asn1SccPioHwas_mPortOerAddress* pVal1, const asn1SccPioHwas_mPortOerAddress* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccPioHwas_mPortOdrAddress_Equal(const asn1SccPioHwas_mPortOdrAddress* pVal1, const asn1SccPioHwas_mPortOdrAddress* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccPioHwas_mPortIfdrAddress_Equal(const asn1SccPioHwas_mPortIfdrAddress* pVal1, const asn1SccPioHwas_mPortIfdrAddress* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccPioHwas_mPortSodrAddress_Equal(const asn1SccPioHwas_mPortSodrAddress* pVal1, const asn1SccPioHwas_mPortSodrAddress* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccPioHwas_mPortCodrAddress_Equal(const asn1SccPioHwas_mPortCodrAddress* pVal1, const asn1SccPioHwas_mPortCodrAddress* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccPioHwas_mPortMddrAddress_Equal(const asn1SccPioHwas_mPortMddrAddress* pVal1, const asn1SccPioHwas_mPortMddrAddress* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccPioHwas_mPortPudrAddress_Equal(const asn1SccPioHwas_mPortPudrAddress* pVal1, const asn1SccPioHwas_mPortPudrAddress* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccPioHwas_mPortOwerAddress_Equal(const asn1SccPioHwas_mPortOwerAddress* pVal1, const asn1SccPioHwas_mPortOwerAddress* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccPioHwas_mPortOwdrAddress_Equal(const asn1SccPioHwas_mPortOwdrAddress* pVal1, const asn1SccPioHwas_mPortOwdrAddress* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccPioHwas_mPortIfscdrAddress_Equal(const asn1SccPioHwas_mPortIfscdrAddress* pVal1, const asn1SccPioHwas_mPortIfscdrAddress* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccPioHwas_mPortPpddrAddress_Equal(const asn1SccPioHwas_mPortPpddrAddress* pVal1, const asn1SccPioHwas_mPortPpddrAddress* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccPioHwas_mPortSchmittAddress_Equal(const asn1SccPioHwas_mPortSchmittAddress* pVal1, const asn1SccPioHwas_mPortSchmittAddress* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccPioHwas_Equal(const asn1SccPioHwas* pVal1, const asn1SccPioHwas* pVal2)
{
	flag ret=TRUE;

    ret = asn1SccPioHwas_mPortAddress_Equal((&(pVal1->mPortAddress)), (&(pVal2->mPortAddress)));

    if (ret) {
        ret = asn1SccPioHwas_mPin_Equal((&(pVal1->mPin)), (&(pVal2->mPin)));

        if (ret) {
            ret = asn1SccPioHwas_mPortPerAddress_Equal((&(pVal1->mPortPerAddress)), (&(pVal2->mPortPerAddress)));

            if (ret) {
                ret = asn1SccPioHwas_mPortOerAddress_Equal((&(pVal1->mPortOerAddress)), (&(pVal2->mPortOerAddress)));

                if (ret) {
                    ret = asn1SccPioHwas_mPortOdrAddress_Equal((&(pVal1->mPortOdrAddress)), (&(pVal2->mPortOdrAddress)));

                    if (ret) {
                        ret = asn1SccPioHwas_mPortIfdrAddress_Equal((&(pVal1->mPortIfdrAddress)), (&(pVal2->mPortIfdrAddress)));

                        if (ret) {
                            ret = asn1SccPioHwas_mPortSodrAddress_Equal((&(pVal1->mPortSodrAddress)), (&(pVal2->mPortSodrAddress)));

                            if (ret) {
                                ret = asn1SccPioHwas_mPortCodrAddress_Equal((&(pVal1->mPortCodrAddress)), (&(pVal2->mPortCodrAddress)));

                                if (ret) {
                                    ret = asn1SccPioHwas_mPortMddrAddress_Equal((&(pVal1->mPortMddrAddress)), (&(pVal2->mPortMddrAddress)));

                                    if (ret) {
                                        ret = asn1SccPioHwas_mPortPudrAddress_Equal((&(pVal1->mPortPudrAddress)), (&(pVal2->mPortPudrAddress)));

                                        if (ret) {
                                            ret = asn1SccPioHwas_mPortOwerAddress_Equal((&(pVal1->mPortOwerAddress)), (&(pVal2->mPortOwerAddress)));

                                            if (ret) {
                                                ret = asn1SccPioHwas_mPortOwdrAddress_Equal((&(pVal1->mPortOwdrAddress)), (&(pVal2->mPortOwdrAddress)));

                                                if (ret) {
                                                    ret = asn1SccPioHwas_mPortIfscdrAddress_Equal((&(pVal1->mPortIfscdrAddress)), (&(pVal2->mPortIfscdrAddress)));

                                                    if (ret) {
                                                        ret = asn1SccPioHwas_mPortPpddrAddress_Equal((&(pVal1->mPortPpddrAddress)), (&(pVal2->mPortPpddrAddress)));

                                                        if (ret) {
                                                            ret = asn1SccPioHwas_mPortSchmittAddress_Equal((&(pVal1->mPortSchmittAddress)), (&(pVal2->mPortSchmittAddress)));

                                                        }

                                                    }

                                                }

                                            }

                                        }

                                    }

                                }

                            }

                        }

                    }

                }

            }

        }

    }

	return ret;

}

void asn1SccPioHwas_mPortAddress_Initialize(asn1SccPioHwas_mPortAddress* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}
void asn1SccPioHwas_mPin_Initialize(asn1SccPioHwas_mPin* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}
void asn1SccPioHwas_mPortPerAddress_Initialize(asn1SccPioHwas_mPortPerAddress* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}
void asn1SccPioHwas_mPortOerAddress_Initialize(asn1SccPioHwas_mPortOerAddress* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}
void asn1SccPioHwas_mPortOdrAddress_Initialize(asn1SccPioHwas_mPortOdrAddress* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}
void asn1SccPioHwas_mPortIfdrAddress_Initialize(asn1SccPioHwas_mPortIfdrAddress* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}
void asn1SccPioHwas_mPortSodrAddress_Initialize(asn1SccPioHwas_mPortSodrAddress* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}
void asn1SccPioHwas_mPortCodrAddress_Initialize(asn1SccPioHwas_mPortCodrAddress* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}
void asn1SccPioHwas_mPortMddrAddress_Initialize(asn1SccPioHwas_mPortMddrAddress* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}
void asn1SccPioHwas_mPortPudrAddress_Initialize(asn1SccPioHwas_mPortPudrAddress* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}
void asn1SccPioHwas_mPortOwerAddress_Initialize(asn1SccPioHwas_mPortOwerAddress* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}
void asn1SccPioHwas_mPortOwdrAddress_Initialize(asn1SccPioHwas_mPortOwdrAddress* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}
void asn1SccPioHwas_mPortIfscdrAddress_Initialize(asn1SccPioHwas_mPortIfscdrAddress* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}
void asn1SccPioHwas_mPortPpddrAddress_Initialize(asn1SccPioHwas_mPortPpddrAddress* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}
void asn1SccPioHwas_mPortSchmittAddress_Initialize(asn1SccPioHwas_mPortSchmittAddress* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}
void asn1SccPioHwas_Initialize(asn1SccPioHwas* pVal)
{
	(void)pVal;



	/*set mPortAddress */
	asn1SccPioHwas_mPortAddress_Initialize((&(pVal->mPortAddress)));
	/*set mPin */
	asn1SccPioHwas_mPin_Initialize((&(pVal->mPin)));
	/*set mPortPerAddress */
	asn1SccPioHwas_mPortPerAddress_Initialize((&(pVal->mPortPerAddress)));
	/*set mPortOerAddress */
	asn1SccPioHwas_mPortOerAddress_Initialize((&(pVal->mPortOerAddress)));
	/*set mPortOdrAddress */
	asn1SccPioHwas_mPortOdrAddress_Initialize((&(pVal->mPortOdrAddress)));
	/*set mPortIfdrAddress */
	asn1SccPioHwas_mPortIfdrAddress_Initialize((&(pVal->mPortIfdrAddress)));
	/*set mPortSodrAddress */
	asn1SccPioHwas_mPortSodrAddress_Initialize((&(pVal->mPortSodrAddress)));
	/*set mPortCodrAddress */
	asn1SccPioHwas_mPortCodrAddress_Initialize((&(pVal->mPortCodrAddress)));
	/*set mPortMddrAddress */
	asn1SccPioHwas_mPortMddrAddress_Initialize((&(pVal->mPortMddrAddress)));
	/*set mPortPudrAddress */
	asn1SccPioHwas_mPortPudrAddress_Initialize((&(pVal->mPortPudrAddress)));
	/*set mPortOwerAddress */
	asn1SccPioHwas_mPortOwerAddress_Initialize((&(pVal->mPortOwerAddress)));
	/*set mPortOwdrAddress */
	asn1SccPioHwas_mPortOwdrAddress_Initialize((&(pVal->mPortOwdrAddress)));
	/*set mPortIfscdrAddress */
	asn1SccPioHwas_mPortIfscdrAddress_Initialize((&(pVal->mPortIfscdrAddress)));
	/*set mPortPpddrAddress */
	asn1SccPioHwas_mPortPpddrAddress_Initialize((&(pVal->mPortPpddrAddress)));
	/*set mPortSchmittAddress */
	asn1SccPioHwas_mPortSchmittAddress_Initialize((&(pVal->mPortSchmittAddress)));
}

flag asn1SccPioHwas_IsConstraintValid(const asn1SccPioHwas* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = (pVal->mPortAddress <= 4294967295UL);
    if (ret) {
        ret = (pVal->mPortAddress <= 4294967295UL);
    }
    *pErrCode = ret ? 0 :  ERR_PIOHWAS_MPORTADDRESS; 
    if (ret) {
        ret = (pVal->mPin <= 4294967295UL);
        if (ret) {
            ret = (pVal->mPin <= 4294967295UL);
        }
        *pErrCode = ret ? 0 :  ERR_PIOHWAS_MPIN; 
        if (ret) {
            ret = (pVal->mPortPerAddress <= 4294967295UL);
            if (ret) {
                ret = (pVal->mPortPerAddress <= 4294967295UL);
            }
            *pErrCode = ret ? 0 :  ERR_PIOHWAS_MPORTPERADDRESS; 
            if (ret) {
                ret = (pVal->mPortOerAddress <= 4294967295UL);
                if (ret) {
                    ret = (pVal->mPortOerAddress <= 4294967295UL);
                }
                *pErrCode = ret ? 0 :  ERR_PIOHWAS_MPORTOERADDRESS; 
                if (ret) {
                    ret = (pVal->mPortOdrAddress <= 4294967295UL);
                    if (ret) {
                        ret = (pVal->mPortOdrAddress <= 4294967295UL);
                    }
                    *pErrCode = ret ? 0 :  ERR_PIOHWAS_MPORTODRADDRESS; 
                    if (ret) {
                        ret = (pVal->mPortIfdrAddress <= 4294967295UL);
                        if (ret) {
                            ret = (pVal->mPortIfdrAddress <= 4294967295UL);
                        }
                        *pErrCode = ret ? 0 :  ERR_PIOHWAS_MPORTIFDRADDRESS; 
                        if (ret) {
                            ret = (pVal->mPortSodrAddress <= 4294967295UL);
                            if (ret) {
                                ret = (pVal->mPortSodrAddress <= 4294967295UL);
                            }
                            *pErrCode = ret ? 0 :  ERR_PIOHWAS_MPORTSODRADDRESS; 
                            if (ret) {
                                ret = (pVal->mPortCodrAddress <= 4294967295UL);
                                if (ret) {
                                    ret = (pVal->mPortCodrAddress <= 4294967295UL);
                                }
                                *pErrCode = ret ? 0 :  ERR_PIOHWAS_MPORTCODRADDRESS; 
                                if (ret) {
                                    ret = (pVal->mPortMddrAddress <= 4294967295UL);
                                    if (ret) {
                                        ret = (pVal->mPortMddrAddress <= 4294967295UL);
                                    }
                                    *pErrCode = ret ? 0 :  ERR_PIOHWAS_MPORTMDDRADDRESS; 
                                    if (ret) {
                                        ret = (pVal->mPortPudrAddress <= 4294967295UL);
                                        if (ret) {
                                            ret = (pVal->mPortPudrAddress <= 4294967295UL);
                                        }
                                        *pErrCode = ret ? 0 :  ERR_PIOHWAS_MPORTPUDRADDRESS; 
                                        if (ret) {
                                            ret = (pVal->mPortOwerAddress <= 4294967295UL);
                                            if (ret) {
                                                ret = (pVal->mPortOwerAddress <= 4294967295UL);
                                            }
                                            *pErrCode = ret ? 0 :  ERR_PIOHWAS_MPORTOWERADDRESS; 
                                            if (ret) {
                                                ret = (pVal->mPortOwdrAddress <= 4294967295UL);
                                                if (ret) {
                                                    ret = (pVal->mPortOwdrAddress <= 4294967295UL);
                                                }
                                                *pErrCode = ret ? 0 :  ERR_PIOHWAS_MPORTOWDRADDRESS; 
                                                if (ret) {
                                                    ret = (pVal->mPortIfscdrAddress <= 4294967295UL);
                                                    if (ret) {
                                                        ret = (pVal->mPortIfscdrAddress <= 4294967295UL);
                                                    }
                                                    *pErrCode = ret ? 0 :  ERR_PIOHWAS_MPORTIFSCDRADDRESS; 
                                                    if (ret) {
                                                        ret = (pVal->mPortPpddrAddress <= 4294967295UL);
                                                        if (ret) {
                                                            ret = (pVal->mPortPpddrAddress <= 4294967295UL);
                                                        }
                                                        *pErrCode = ret ? 0 :  ERR_PIOHWAS_MPORTPPDDRADDRESS; 
                                                        if (ret) {
                                                            ret = (pVal->mPortSchmittAddress <= 4294967295UL);
                                                            if (ret) {
                                                                ret = (pVal->mPortSchmittAddress <= 4294967295UL);
                                                            }
                                                            *pErrCode = ret ? 0 :  ERR_PIOHWAS_MPORTSCHMITTADDRESS; 
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag asn1SccPioHwas_Encode(const asn1SccPioHwas* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccPioHwas_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode mPortAddress */
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->mPortAddress, 0, 4294967295LL);
	    if (ret) {
	        /*Encode mPin */
	        BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->mPin, 0, 4294967295LL);
	        if (ret) {
	            /*Encode mPortPerAddress */
	            BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->mPortPerAddress, 0, 4294967295LL);
	            if (ret) {
	                /*Encode mPortOerAddress */
	                BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->mPortOerAddress, 0, 4294967295LL);
	                if (ret) {
	                    /*Encode mPortOdrAddress */
	                    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->mPortOdrAddress, 0, 4294967295LL);
	                    if (ret) {
	                        /*Encode mPortIfdrAddress */
	                        BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->mPortIfdrAddress, 0, 4294967295LL);
	                        if (ret) {
	                            /*Encode mPortSodrAddress */
	                            BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->mPortSodrAddress, 0, 4294967295LL);
	                            if (ret) {
	                                /*Encode mPortCodrAddress */
	                                BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->mPortCodrAddress, 0, 4294967295LL);
	                                if (ret) {
	                                    /*Encode mPortMddrAddress */
	                                    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->mPortMddrAddress, 0, 4294967295LL);
	                                    if (ret) {
	                                        /*Encode mPortPudrAddress */
	                                        BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->mPortPudrAddress, 0, 4294967295LL);
	                                        if (ret) {
	                                            /*Encode mPortOwerAddress */
	                                            BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->mPortOwerAddress, 0, 4294967295LL);
	                                            if (ret) {
	                                                /*Encode mPortOwdrAddress */
	                                                BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->mPortOwdrAddress, 0, 4294967295LL);
	                                                if (ret) {
	                                                    /*Encode mPortIfscdrAddress */
	                                                    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->mPortIfscdrAddress, 0, 4294967295LL);
	                                                    if (ret) {
	                                                        /*Encode mPortPpddrAddress */
	                                                        BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->mPortPpddrAddress, 0, 4294967295LL);
	                                                        if (ret) {
	                                                            /*Encode mPortSchmittAddress */
	                                                            BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->mPortSchmittAddress, 0, 4294967295LL);
	                                                        }
	                                                    }
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccPioHwas_Decode(asn1SccPioHwas* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode mPortAddress */
	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->mPortAddress)), 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_PIOHWAS_MPORTADDRESS;
	if (ret) {
	    /*Decode mPin */
	    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->mPin)), 0, 4294967295LL);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_PIOHWAS_MPIN;
	    if (ret) {
	        /*Decode mPortPerAddress */
	        ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->mPortPerAddress)), 0, 4294967295LL);
	        *pErrCode = ret ? 0 : ERR_UPER_DECODE_PIOHWAS_MPORTPERADDRESS;
	        if (ret) {
	            /*Decode mPortOerAddress */
	            ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->mPortOerAddress)), 0, 4294967295LL);
	            *pErrCode = ret ? 0 : ERR_UPER_DECODE_PIOHWAS_MPORTOERADDRESS;
	            if (ret) {
	                /*Decode mPortOdrAddress */
	                ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->mPortOdrAddress)), 0, 4294967295LL);
	                *pErrCode = ret ? 0 : ERR_UPER_DECODE_PIOHWAS_MPORTODRADDRESS;
	                if (ret) {
	                    /*Decode mPortIfdrAddress */
	                    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->mPortIfdrAddress)), 0, 4294967295LL);
	                    *pErrCode = ret ? 0 : ERR_UPER_DECODE_PIOHWAS_MPORTIFDRADDRESS;
	                    if (ret) {
	                        /*Decode mPortSodrAddress */
	                        ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->mPortSodrAddress)), 0, 4294967295LL);
	                        *pErrCode = ret ? 0 : ERR_UPER_DECODE_PIOHWAS_MPORTSODRADDRESS;
	                        if (ret) {
	                            /*Decode mPortCodrAddress */
	                            ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->mPortCodrAddress)), 0, 4294967295LL);
	                            *pErrCode = ret ? 0 : ERR_UPER_DECODE_PIOHWAS_MPORTCODRADDRESS;
	                            if (ret) {
	                                /*Decode mPortMddrAddress */
	                                ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->mPortMddrAddress)), 0, 4294967295LL);
	                                *pErrCode = ret ? 0 : ERR_UPER_DECODE_PIOHWAS_MPORTMDDRADDRESS;
	                                if (ret) {
	                                    /*Decode mPortPudrAddress */
	                                    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->mPortPudrAddress)), 0, 4294967295LL);
	                                    *pErrCode = ret ? 0 : ERR_UPER_DECODE_PIOHWAS_MPORTPUDRADDRESS;
	                                    if (ret) {
	                                        /*Decode mPortOwerAddress */
	                                        ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->mPortOwerAddress)), 0, 4294967295LL);
	                                        *pErrCode = ret ? 0 : ERR_UPER_DECODE_PIOHWAS_MPORTOWERADDRESS;
	                                        if (ret) {
	                                            /*Decode mPortOwdrAddress */
	                                            ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->mPortOwdrAddress)), 0, 4294967295LL);
	                                            *pErrCode = ret ? 0 : ERR_UPER_DECODE_PIOHWAS_MPORTOWDRADDRESS;
	                                            if (ret) {
	                                                /*Decode mPortIfscdrAddress */
	                                                ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->mPortIfscdrAddress)), 0, 4294967295LL);
	                                                *pErrCode = ret ? 0 : ERR_UPER_DECODE_PIOHWAS_MPORTIFSCDRADDRESS;
	                                                if (ret) {
	                                                    /*Decode mPortPpddrAddress */
	                                                    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->mPortPpddrAddress)), 0, 4294967295LL);
	                                                    *pErrCode = ret ? 0 : ERR_UPER_DECODE_PIOHWAS_MPORTPPDDRADDRESS;
	                                                    if (ret) {
	                                                        /*Decode mPortSchmittAddress */
	                                                        ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->mPortSchmittAddress)), 0, 4294967295LL);
	                                                        *pErrCode = ret ? 0 : ERR_UPER_DECODE_PIOHWAS_MPORTSCHMITTADDRESS;
	                                                    }
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && asn1SccPioHwas_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccPioHwas_ACN_Encode(const asn1SccPioHwas* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccPioHwas_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode mPortAddress */
	    Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, pVal->mPortAddress);
	    if (ret) {
	        /*Encode mPin */
	        Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, pVal->mPin);
	        if (ret) {
	            /*Encode mPortPerAddress */
	            Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, pVal->mPortPerAddress);
	            if (ret) {
	                /*Encode mPortOerAddress */
	                Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, pVal->mPortOerAddress);
	                if (ret) {
	                    /*Encode mPortOdrAddress */
	                    Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, pVal->mPortOdrAddress);
	                    if (ret) {
	                        /*Encode mPortIfdrAddress */
	                        Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, pVal->mPortIfdrAddress);
	                        if (ret) {
	                            /*Encode mPortSodrAddress */
	                            Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, pVal->mPortSodrAddress);
	                            if (ret) {
	                                /*Encode mPortCodrAddress */
	                                Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, pVal->mPortCodrAddress);
	                                if (ret) {
	                                    /*Encode mPortMddrAddress */
	                                    Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, pVal->mPortMddrAddress);
	                                    if (ret) {
	                                        /*Encode mPortPudrAddress */
	                                        Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, pVal->mPortPudrAddress);
	                                        if (ret) {
	                                            /*Encode mPortOwerAddress */
	                                            Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, pVal->mPortOwerAddress);
	                                            if (ret) {
	                                                /*Encode mPortOwdrAddress */
	                                                Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, pVal->mPortOwdrAddress);
	                                                if (ret) {
	                                                    /*Encode mPortIfscdrAddress */
	                                                    Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, pVal->mPortIfscdrAddress);
	                                                    if (ret) {
	                                                        /*Encode mPortPpddrAddress */
	                                                        Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, pVal->mPortPpddrAddress);
	                                                        if (ret) {
	                                                            /*Encode mPortSchmittAddress */
	                                                            Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, pVal->mPortSchmittAddress);
	                                                        }

	                                                    }

	                                                }

	                                            }

	                                        }

	                                    }

	                                }

	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccPioHwas_ACN_Decode(asn1SccPioHwas* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode mPortAddress */
	ret = Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, (&(pVal->mPortAddress)));
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_PIOHWAS_MPORTADDRESS;
	if (ret) {
	    /*Decode mPin */
	    ret = Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, (&(pVal->mPin)));
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_PIOHWAS_MPIN;
	    if (ret) {
	        /*Decode mPortPerAddress */
	        ret = Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, (&(pVal->mPortPerAddress)));
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_PIOHWAS_MPORTPERADDRESS;
	        if (ret) {
	            /*Decode mPortOerAddress */
	            ret = Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, (&(pVal->mPortOerAddress)));
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_PIOHWAS_MPORTOERADDRESS;
	            if (ret) {
	                /*Decode mPortOdrAddress */
	                ret = Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, (&(pVal->mPortOdrAddress)));
	                *pErrCode = ret ? 0 : ERR_ACN_DECODE_PIOHWAS_MPORTODRADDRESS;
	                if (ret) {
	                    /*Decode mPortIfdrAddress */
	                    ret = Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, (&(pVal->mPortIfdrAddress)));
	                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_PIOHWAS_MPORTIFDRADDRESS;
	                    if (ret) {
	                        /*Decode mPortSodrAddress */
	                        ret = Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, (&(pVal->mPortSodrAddress)));
	                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_PIOHWAS_MPORTSODRADDRESS;
	                        if (ret) {
	                            /*Decode mPortCodrAddress */
	                            ret = Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, (&(pVal->mPortCodrAddress)));
	                            *pErrCode = ret ? 0 : ERR_ACN_DECODE_PIOHWAS_MPORTCODRADDRESS;
	                            if (ret) {
	                                /*Decode mPortMddrAddress */
	                                ret = Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, (&(pVal->mPortMddrAddress)));
	                                *pErrCode = ret ? 0 : ERR_ACN_DECODE_PIOHWAS_MPORTMDDRADDRESS;
	                                if (ret) {
	                                    /*Decode mPortPudrAddress */
	                                    ret = Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, (&(pVal->mPortPudrAddress)));
	                                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_PIOHWAS_MPORTPUDRADDRESS;
	                                    if (ret) {
	                                        /*Decode mPortOwerAddress */
	                                        ret = Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, (&(pVal->mPortOwerAddress)));
	                                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_PIOHWAS_MPORTOWERADDRESS;
	                                        if (ret) {
	                                            /*Decode mPortOwdrAddress */
	                                            ret = Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, (&(pVal->mPortOwdrAddress)));
	                                            *pErrCode = ret ? 0 : ERR_ACN_DECODE_PIOHWAS_MPORTOWDRADDRESS;
	                                            if (ret) {
	                                                /*Decode mPortIfscdrAddress */
	                                                ret = Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, (&(pVal->mPortIfscdrAddress)));
	                                                *pErrCode = ret ? 0 : ERR_ACN_DECODE_PIOHWAS_MPORTIFSCDRADDRESS;
	                                                if (ret) {
	                                                    /*Decode mPortPpddrAddress */
	                                                    ret = Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, (&(pVal->mPortPpddrAddress)));
	                                                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_PIOHWAS_MPORTPPDDRADDRESS;
	                                                    if (ret) {
	                                                        /*Decode mPortSchmittAddress */
	                                                        ret = Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, (&(pVal->mPortSchmittAddress)));
	                                                        *pErrCode = ret ? 0 : ERR_ACN_DECODE_PIOHWAS_MPORTSCHMITTADDRESS;
	                                                    }

	                                                }

	                                            }

	                                        }

	                                    }

	                                }

	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

	}


    return ret && asn1SccPioHwas_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccPmcHwas_pMC_PCSR0_OFFSET_Equal(const asn1SccPmcHwas_pMC_PCSR0_OFFSET* pVal1, const asn1SccPmcHwas_pMC_PCSR0_OFFSET* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccPmcHwas_pMC_PCxR0_PID10_PIOA_MASK_Equal(const asn1SccPmcHwas_pMC_PCxR0_PID10_PIOA_MASK* pVal1, const asn1SccPmcHwas_pMC_PCxR0_PID10_PIOA_MASK* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccPmcHwas_pMC_PCxR0_PID11_PIOB_MASK_Equal(const asn1SccPmcHwas_pMC_PCxR0_PID11_PIOB_MASK* pVal1, const asn1SccPmcHwas_pMC_PCxR0_PID11_PIOB_MASK* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccPmcHwas_pMC_PCxR0_PID12_PIOC_MASK_Equal(const asn1SccPmcHwas_pMC_PCxR0_PID12_PIOC_MASK* pVal1, const asn1SccPmcHwas_pMC_PCxR0_PID12_PIOC_MASK* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccPmcHwas_pMC_PCxR0_PID16_PIOD_MASK_Equal(const asn1SccPmcHwas_pMC_PCxR0_PID16_PIOD_MASK* pVal1, const asn1SccPmcHwas_pMC_PCxR0_PID16_PIOD_MASK* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccPmcHwas_pMC_PCxR0_PID17_PIOE_MASK_Equal(const asn1SccPmcHwas_pMC_PCxR0_PID17_PIOE_MASK* pVal1, const asn1SccPmcHwas_pMC_PCxR0_PID17_PIOE_MASK* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccPmcHwas_Equal(const asn1SccPmcHwas* pVal1, const asn1SccPmcHwas* pVal2)
{
	flag ret=TRUE;

    ret = asn1SccPmcHwas_pMC_PCSR0_OFFSET_Equal((&(pVal1->pMC_PCSR0_OFFSET)), (&(pVal2->pMC_PCSR0_OFFSET)));

    if (ret) {
        ret = asn1SccPmcHwas_pMC_PCxR0_PID10_PIOA_MASK_Equal((&(pVal1->pMC_PCxR0_PID10_PIOA_MASK)), (&(pVal2->pMC_PCxR0_PID10_PIOA_MASK)));

        if (ret) {
            ret = asn1SccPmcHwas_pMC_PCxR0_PID11_PIOB_MASK_Equal((&(pVal1->pMC_PCxR0_PID11_PIOB_MASK)), (&(pVal2->pMC_PCxR0_PID11_PIOB_MASK)));

            if (ret) {
                ret = asn1SccPmcHwas_pMC_PCxR0_PID12_PIOC_MASK_Equal((&(pVal1->pMC_PCxR0_PID12_PIOC_MASK)), (&(pVal2->pMC_PCxR0_PID12_PIOC_MASK)));

                if (ret) {
                    ret = asn1SccPmcHwas_pMC_PCxR0_PID16_PIOD_MASK_Equal((&(pVal1->pMC_PCxR0_PID16_PIOD_MASK)), (&(pVal2->pMC_PCxR0_PID16_PIOD_MASK)));

                    if (ret) {
                        ret = asn1SccPmcHwas_pMC_PCxR0_PID17_PIOE_MASK_Equal((&(pVal1->pMC_PCxR0_PID17_PIOE_MASK)), (&(pVal2->pMC_PCxR0_PID17_PIOE_MASK)));

                    }

                }

            }

        }

    }

	return ret;

}

void asn1SccPmcHwas_pMC_PCSR0_OFFSET_Initialize(asn1SccPmcHwas_pMC_PCSR0_OFFSET* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}
void asn1SccPmcHwas_pMC_PCxR0_PID10_PIOA_MASK_Initialize(asn1SccPmcHwas_pMC_PCxR0_PID10_PIOA_MASK* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}
void asn1SccPmcHwas_pMC_PCxR0_PID11_PIOB_MASK_Initialize(asn1SccPmcHwas_pMC_PCxR0_PID11_PIOB_MASK* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}
void asn1SccPmcHwas_pMC_PCxR0_PID12_PIOC_MASK_Initialize(asn1SccPmcHwas_pMC_PCxR0_PID12_PIOC_MASK* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}
void asn1SccPmcHwas_pMC_PCxR0_PID16_PIOD_MASK_Initialize(asn1SccPmcHwas_pMC_PCxR0_PID16_PIOD_MASK* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}
void asn1SccPmcHwas_pMC_PCxR0_PID17_PIOE_MASK_Initialize(asn1SccPmcHwas_pMC_PCxR0_PID17_PIOE_MASK* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}
void asn1SccPmcHwas_Initialize(asn1SccPmcHwas* pVal)
{
	(void)pVal;



	/*set pMC_PCSR0_OFFSET */
	asn1SccPmcHwas_pMC_PCSR0_OFFSET_Initialize((&(pVal->pMC_PCSR0_OFFSET)));
	/*set pMC_PCxR0_PID10_PIOA_MASK */
	asn1SccPmcHwas_pMC_PCxR0_PID10_PIOA_MASK_Initialize((&(pVal->pMC_PCxR0_PID10_PIOA_MASK)));
	/*set pMC_PCxR0_PID11_PIOB_MASK */
	asn1SccPmcHwas_pMC_PCxR0_PID11_PIOB_MASK_Initialize((&(pVal->pMC_PCxR0_PID11_PIOB_MASK)));
	/*set pMC_PCxR0_PID12_PIOC_MASK */
	asn1SccPmcHwas_pMC_PCxR0_PID12_PIOC_MASK_Initialize((&(pVal->pMC_PCxR0_PID12_PIOC_MASK)));
	/*set pMC_PCxR0_PID16_PIOD_MASK */
	asn1SccPmcHwas_pMC_PCxR0_PID16_PIOD_MASK_Initialize((&(pVal->pMC_PCxR0_PID16_PIOD_MASK)));
	/*set pMC_PCxR0_PID17_PIOE_MASK */
	asn1SccPmcHwas_pMC_PCxR0_PID17_PIOE_MASK_Initialize((&(pVal->pMC_PCxR0_PID17_PIOE_MASK)));
}

flag asn1SccPmcHwas_IsConstraintValid(const asn1SccPmcHwas* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = (pVal->pMC_PCSR0_OFFSET <= 4294967295UL);
    if (ret) {
        ret = (pVal->pMC_PCSR0_OFFSET <= 4294967295UL);
    }
    *pErrCode = ret ? 0 :  ERR_PMCHWAS_PMC_PCSR0_OFFSET; 
    if (ret) {
        ret = (pVal->pMC_PCxR0_PID10_PIOA_MASK <= 4294967295UL);
        if (ret) {
            ret = (pVal->pMC_PCxR0_PID10_PIOA_MASK <= 4294967295UL);
        }
        *pErrCode = ret ? 0 :  ERR_PMCHWAS_PMC_PCXR0_PID10_PIOA_MASK; 
        if (ret) {
            ret = (pVal->pMC_PCxR0_PID11_PIOB_MASK <= 4294967295UL);
            if (ret) {
                ret = (pVal->pMC_PCxR0_PID11_PIOB_MASK <= 4294967295UL);
            }
            *pErrCode = ret ? 0 :  ERR_PMCHWAS_PMC_PCXR0_PID11_PIOB_MASK; 
            if (ret) {
                ret = (pVal->pMC_PCxR0_PID12_PIOC_MASK <= 4294967295UL);
                if (ret) {
                    ret = (pVal->pMC_PCxR0_PID12_PIOC_MASK <= 4294967295UL);
                }
                *pErrCode = ret ? 0 :  ERR_PMCHWAS_PMC_PCXR0_PID12_PIOC_MASK; 
                if (ret) {
                    ret = (pVal->pMC_PCxR0_PID16_PIOD_MASK <= 4294967295UL);
                    if (ret) {
                        ret = (pVal->pMC_PCxR0_PID16_PIOD_MASK <= 4294967295UL);
                    }
                    *pErrCode = ret ? 0 :  ERR_PMCHWAS_PMC_PCXR0_PID16_PIOD_MASK; 
                    if (ret) {
                        ret = (pVal->pMC_PCxR0_PID17_PIOE_MASK <= 4294967295UL);
                        if (ret) {
                            ret = (pVal->pMC_PCxR0_PID17_PIOE_MASK <= 4294967295UL);
                        }
                        *pErrCode = ret ? 0 :  ERR_PMCHWAS_PMC_PCXR0_PID17_PIOE_MASK; 
                    }
                }
            }
        }
    }

	return ret;
}

flag asn1SccPmcHwas_Encode(const asn1SccPmcHwas* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccPmcHwas_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode pMC_PCSR0_OFFSET */
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->pMC_PCSR0_OFFSET, 0, 4294967295LL);
	    if (ret) {
	        /*Encode pMC_PCxR0_PID10_PIOA_MASK */
	        BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->pMC_PCxR0_PID10_PIOA_MASK, 0, 4294967295LL);
	        if (ret) {
	            /*Encode pMC_PCxR0_PID11_PIOB_MASK */
	            BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->pMC_PCxR0_PID11_PIOB_MASK, 0, 4294967295LL);
	            if (ret) {
	                /*Encode pMC_PCxR0_PID12_PIOC_MASK */
	                BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->pMC_PCxR0_PID12_PIOC_MASK, 0, 4294967295LL);
	                if (ret) {
	                    /*Encode pMC_PCxR0_PID16_PIOD_MASK */
	                    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->pMC_PCxR0_PID16_PIOD_MASK, 0, 4294967295LL);
	                    if (ret) {
	                        /*Encode pMC_PCxR0_PID17_PIOE_MASK */
	                        BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->pMC_PCxR0_PID17_PIOE_MASK, 0, 4294967295LL);
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccPmcHwas_Decode(asn1SccPmcHwas* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode pMC_PCSR0_OFFSET */
	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->pMC_PCSR0_OFFSET)), 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_PMCHWAS_PMC_PCSR0_OFFSET;
	if (ret) {
	    /*Decode pMC_PCxR0_PID10_PIOA_MASK */
	    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->pMC_PCxR0_PID10_PIOA_MASK)), 0, 4294967295LL);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_PMCHWAS_PMC_PCXR0_PID10_PIOA_MASK;
	    if (ret) {
	        /*Decode pMC_PCxR0_PID11_PIOB_MASK */
	        ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->pMC_PCxR0_PID11_PIOB_MASK)), 0, 4294967295LL);
	        *pErrCode = ret ? 0 : ERR_UPER_DECODE_PMCHWAS_PMC_PCXR0_PID11_PIOB_MASK;
	        if (ret) {
	            /*Decode pMC_PCxR0_PID12_PIOC_MASK */
	            ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->pMC_PCxR0_PID12_PIOC_MASK)), 0, 4294967295LL);
	            *pErrCode = ret ? 0 : ERR_UPER_DECODE_PMCHWAS_PMC_PCXR0_PID12_PIOC_MASK;
	            if (ret) {
	                /*Decode pMC_PCxR0_PID16_PIOD_MASK */
	                ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->pMC_PCxR0_PID16_PIOD_MASK)), 0, 4294967295LL);
	                *pErrCode = ret ? 0 : ERR_UPER_DECODE_PMCHWAS_PMC_PCXR0_PID16_PIOD_MASK;
	                if (ret) {
	                    /*Decode pMC_PCxR0_PID17_PIOE_MASK */
	                    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->pMC_PCxR0_PID17_PIOE_MASK)), 0, 4294967295LL);
	                    *pErrCode = ret ? 0 : ERR_UPER_DECODE_PMCHWAS_PMC_PCXR0_PID17_PIOE_MASK;
	                }
	            }
	        }
	    }
	}

	return ret  && asn1SccPmcHwas_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccPmcHwas_ACN_Encode(const asn1SccPmcHwas* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccPmcHwas_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode pMC_PCSR0_OFFSET */
	    Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, pVal->pMC_PCSR0_OFFSET);
	    if (ret) {
	        /*Encode pMC_PCxR0_PID10_PIOA_MASK */
	        Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, pVal->pMC_PCxR0_PID10_PIOA_MASK);
	        if (ret) {
	            /*Encode pMC_PCxR0_PID11_PIOB_MASK */
	            Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, pVal->pMC_PCxR0_PID11_PIOB_MASK);
	            if (ret) {
	                /*Encode pMC_PCxR0_PID12_PIOC_MASK */
	                Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, pVal->pMC_PCxR0_PID12_PIOC_MASK);
	                if (ret) {
	                    /*Encode pMC_PCxR0_PID16_PIOD_MASK */
	                    Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, pVal->pMC_PCxR0_PID16_PIOD_MASK);
	                    if (ret) {
	                        /*Encode pMC_PCxR0_PID17_PIOE_MASK */
	                        Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, pVal->pMC_PCxR0_PID17_PIOE_MASK);
	                    }

	                }

	            }

	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccPmcHwas_ACN_Decode(asn1SccPmcHwas* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode pMC_PCSR0_OFFSET */
	ret = Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, (&(pVal->pMC_PCSR0_OFFSET)));
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_PMCHWAS_PMC_PCSR0_OFFSET;
	if (ret) {
	    /*Decode pMC_PCxR0_PID10_PIOA_MASK */
	    ret = Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, (&(pVal->pMC_PCxR0_PID10_PIOA_MASK)));
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_PMCHWAS_PMC_PCXR0_PID10_PIOA_MASK;
	    if (ret) {
	        /*Decode pMC_PCxR0_PID11_PIOB_MASK */
	        ret = Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, (&(pVal->pMC_PCxR0_PID11_PIOB_MASK)));
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_PMCHWAS_PMC_PCXR0_PID11_PIOB_MASK;
	        if (ret) {
	            /*Decode pMC_PCxR0_PID12_PIOC_MASK */
	            ret = Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, (&(pVal->pMC_PCxR0_PID12_PIOC_MASK)));
	            *pErrCode = ret ? 0 : ERR_ACN_DECODE_PMCHWAS_PMC_PCXR0_PID12_PIOC_MASK;
	            if (ret) {
	                /*Decode pMC_PCxR0_PID16_PIOD_MASK */
	                ret = Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, (&(pVal->pMC_PCxR0_PID16_PIOD_MASK)));
	                *pErrCode = ret ? 0 : ERR_ACN_DECODE_PMCHWAS_PMC_PCXR0_PID16_PIOD_MASK;
	                if (ret) {
	                    /*Decode pMC_PCxR0_PID17_PIOE_MASK */
	                    ret = Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, (&(pVal->pMC_PCxR0_PID17_PIOE_MASK)));
	                    *pErrCode = ret ? 0 : ERR_ACN_DECODE_PMCHWAS_PMC_PCXR0_PID17_PIOE_MASK;
	                }

	            }

	        }

	    }

	}


    return ret && asn1SccPmcHwas_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccBufferSize_Equal(const asn1SccBufferSize* pVal1, const asn1SccBufferSize* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void asn1SccBufferSize_Initialize(asn1SccBufferSize* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccBufferSize_IsConstraintValid(const asn1SccBufferSize* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 65535UL);
    *pErrCode = ret ? 0 :  ERR_BUFFERSIZE; 

	return ret;
}

flag asn1SccBufferSize_Encode(const asn1SccBufferSize* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccBufferSize_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 65535);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccBufferSize_Decode(asn1SccBufferSize* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 65535);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BUFFERSIZE;

	return ret  && asn1SccBufferSize_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccBufferSize_ACN_Encode(const asn1SccBufferSize* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccBufferSize_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_16(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccBufferSize_ACN_Decode(asn1SccBufferSize* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_16(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BUFFERSIZE;

    return ret && asn1SccBufferSize_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccInterruptNumber_Equal(const asn1SccInterruptNumber* pVal1, const asn1SccInterruptNumber* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void asn1SccInterruptNumber_Initialize(asn1SccInterruptNumber* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccInterruptNumber_IsConstraintValid(const asn1SccInterruptNumber* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_INTERRUPTNUMBER; 

	return ret;
}

flag asn1SccInterruptNumber_Encode(const asn1SccInterruptNumber* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccInterruptNumber_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccInterruptNumber_Decode(asn1SccInterruptNumber* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_INTERRUPTNUMBER;

	return ret  && asn1SccInterruptNumber_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccInterruptNumber_ACN_Encode(const asn1SccInterruptNumber* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccInterruptNumber_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    Acn_Enc_Int_PositiveInteger_ConstSize_8(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccInterruptNumber_ACN_Decode(asn1SccInterruptNumber* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = Acn_Dec_Int_PositiveInteger_ConstSize_8(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_INTERRUPTNUMBER;

    return ret && asn1SccInterruptNumber_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccByte_Equal(const asn1SccByte* pVal1, const asn1SccByte* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void asn1SccByte_Initialize(asn1SccByte* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccByte_IsConstraintValid(const asn1SccByte* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_BYTE; 

	return ret;
}

flag asn1SccByte_Encode(const asn1SccByte* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccByte_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccByte_Decode(asn1SccByte* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BYTE;

	return ret  && asn1SccByte_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccByte_ACN_Encode(const asn1SccByte* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccByte_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    Acn_Enc_Int_PositiveInteger_ConstSize_8(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccByte_ACN_Decode(asn1SccByte* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = Acn_Dec_Int_PositiveInteger_ConstSize_8(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BYTE;

    return ret && asn1SccByte_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccByteBuffer_elem_Equal(const asn1SccByteBuffer_elem* pVal1, const asn1SccByteBuffer_elem* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccByteBuffer_Equal(const asn1SccByteBuffer* pVal1, const asn1SccByteBuffer* pVal2)
{
	flag ret=TRUE;
    int i1;

    ret = (pVal1->nCount == pVal2->nCount);
    for(i1 = 0; ret && i1 < pVal1->nCount; i1++) 
    {
    	ret = asn1SccByteBuffer_elem_Equal((&(pVal1->arr[i1])), (&(pVal2->arr[i1])));
    }

	return ret;

}

void asn1SccByteBuffer_elem_Initialize(asn1SccByteBuffer_elem* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}
void asn1SccByteBuffer_Initialize(asn1SccByteBuffer* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 65535) {
	    asn1SccByteBuffer_elem_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 0;
}

flag asn1SccByteBuffer_IsConstraintValid(const asn1SccByteBuffer* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    ret = (pVal->nCount <= 65535);
    *pErrCode = ret ? 0 :  ERR_BYTEBUFFER; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->nCount; i1++) 
        {
        	ret = (pVal->arr[i1] <= 255UL);
        	if (ret) {
        	    ret = (pVal->arr[i1] <= 255UL);
        	}
        	*pErrCode = ret ? 0 :  ERR_BYTEBUFFER_ELM; 
        }
    }

	return ret;
}

flag asn1SccByteBuffer_Encode(const asn1SccByteBuffer* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccByteBuffer_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 0, 65535);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->arr[i1], 0, 255);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccByteBuffer_Decode(asn1SccByteBuffer* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 65535);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BYTEBUFFER;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->arr[i1])), 0, 255);
		*pErrCode = ret ? 0 : ERR_UPER_DECODE_BYTEBUFFER_ELM;
	}

	return ret  && asn1SccByteBuffer_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccByteBuffer_ACN_Encode(const asn1SccByteBuffer* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	int i1;
    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccByteBuffer_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 0, 65535);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	Acn_Enc_Int_PositiveInteger_ConstSize_8(pBitStrm, pVal->arr[i1]);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccByteBuffer_ACN_Decode(asn1SccByteBuffer* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 65535);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_BYTEBUFFER;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = Acn_Dec_Int_PositiveInteger_ConstSize_8(pBitStrm, (&(pVal->arr[i1])));
		*pErrCode = ret ? 0 : ERR_ACN_DECODE_BYTEBUFFER_ELM;
	}

    return ret && asn1SccByteBuffer_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccPinNumber_Equal(const asn1SccPinNumber* pVal1, const asn1SccPinNumber* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void asn1SccPinNumber_Initialize(asn1SccPinNumber* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccPinNumber_IsConstraintValid(const asn1SccPinNumber* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 64UL);
    *pErrCode = ret ? 0 :  ERR_PINNUMBER; 

	return ret;
}

flag asn1SccPinNumber_Encode(const asn1SccPinNumber* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccPinNumber_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 64);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccPinNumber_Decode(asn1SccPinNumber* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 64);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_PINNUMBER;

	return ret  && asn1SccPinNumber_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccPinNumber_ACN_Encode(const asn1SccPinNumber* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccPinNumber_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_16(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccPinNumber_ACN_Decode(asn1SccPinNumber* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_16(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_PINNUMBER;

    return ret && asn1SccPinNumber_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccPioHwas_Port_Equal(const asn1SccPioHwas_Port* pVal1, const asn1SccPioHwas_Port* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void asn1SccPioHwas_Port_Initialize(asn1SccPioHwas_Port* pVal)
{
	(void)pVal;


	(*(pVal)) = asn1SccpioHwas_Port_A;
}

flag asn1SccPioHwas_Port_IsConstraintValid(const asn1SccPioHwas_Port* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((((*(pVal)) == asn1SccpioHwas_Port_A)) || (((*(pVal)) == asn1SccpioHwas_Port_B)))) || (((*(pVal)) == asn1SccpioHwas_Port_C)))) || (((*(pVal)) == asn1SccpioHwas_Port_D)))) || (((*(pVal)) == asn1SccpioHwas_Port_E)));
    *pErrCode = ret ? 0 :  ERR_PIOHWAS_PORT; 

	return ret;
}

flag asn1SccPioHwas_Port_Encode(const asn1SccPioHwas_Port* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccPioHwas_Port_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) 
	    {
	        case asn1SccpioHwas_Port_A:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 4);
	        	break;
	        case asn1SccpioHwas_Port_B:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 4);
	        	break;
	        case asn1SccpioHwas_Port_C:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 4);
	        	break;
	        case asn1SccpioHwas_Port_D:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 4);
	        	break;
	        case asn1SccpioHwas_Port_E:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 4);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_PIOHWAS_PORT; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccPioHwas_Port_Decode(asn1SccPioHwas_Port* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 4);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_PIOHWAS_PORT;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = asn1SccpioHwas_Port_A;
	                break;
	            case 1: 
	                (*(pVal)) = asn1SccpioHwas_Port_B;
	                break;
	            case 2: 
	                (*(pVal)) = asn1SccpioHwas_Port_C;
	                break;
	            case 3: 
	                (*(pVal)) = asn1SccpioHwas_Port_D;
	                break;
	            case 4: 
	                (*(pVal)) = asn1SccpioHwas_Port_E;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_PIOHWAS_PORT;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = asn1SccpioHwas_Port_A;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && asn1SccPioHwas_Port_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccPioHwas_Port_ACN_Encode(const asn1SccPioHwas_Port* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccPioHwas_Port_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) { 
	        case asn1SccpioHwas_Port_A:
	            uIntVal = 0;
	            break;
	        case asn1SccpioHwas_Port_B:
	            uIntVal = 1;
	            break;
	        case asn1SccpioHwas_Port_C:
	            uIntVal = 2;
	            break;
	        case asn1SccpioHwas_Port_D:
	            uIntVal = 3;
	            break;
	        case asn1SccpioHwas_Port_E:
	            uIntVal = 4;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_PIOHWAS_PORT;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, uIntVal);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccPioHwas_Port_ACN_Decode(asn1SccPioHwas_Port* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, (&(uIntVal)));
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_PIOHWAS_PORT;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = asn1SccpioHwas_Port_A;
	            break;
	        case 1:
	            (*(pVal)) = asn1SccpioHwas_Port_B;
	            break;
	        case 2:
	            (*(pVal)) = asn1SccpioHwas_Port_C;
	            break;
	        case 3:
	            (*(pVal)) = asn1SccpioHwas_Port_D;
	            break;
	        case 4:
	            (*(pVal)) = asn1SccpioHwas_Port_E;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_PIOHWAS_PORT;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && asn1SccPioHwas_Port_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccPioHwas_Direction_Equal(const asn1SccPioHwas_Direction* pVal1, const asn1SccPioHwas_Direction* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void asn1SccPioHwas_Direction_Initialize(asn1SccPioHwas_Direction* pVal)
{
	(void)pVal;


	(*(pVal)) = asn1SccpioHwas_Direction_Input;
}

flag asn1SccPioHwas_Direction_IsConstraintValid(const asn1SccPioHwas_Direction* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((*(pVal)) == asn1SccpioHwas_Direction_Input)) || (((*(pVal)) == asn1SccpioHwas_Direction_Output)));
    *pErrCode = ret ? 0 :  ERR_PIOHWAS_DIRECTION; 

	return ret;
}

flag asn1SccPioHwas_Direction_Encode(const asn1SccPioHwas_Direction* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccPioHwas_Direction_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) 
	    {
	        case asn1SccpioHwas_Direction_Input:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case asn1SccpioHwas_Direction_Output:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_PIOHWAS_DIRECTION; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccPioHwas_Direction_Decode(asn1SccPioHwas_Direction* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_PIOHWAS_DIRECTION;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = asn1SccpioHwas_Direction_Input;
	                break;
	            case 1: 
	                (*(pVal)) = asn1SccpioHwas_Direction_Output;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_PIOHWAS_DIRECTION;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = asn1SccpioHwas_Direction_Input;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && asn1SccPioHwas_Direction_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccPioHwas_Direction_ACN_Encode(const asn1SccPioHwas_Direction* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccPioHwas_Direction_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) { 
	        case asn1SccpioHwas_Direction_Input:
	            uIntVal = 0;
	            break;
	        case asn1SccpioHwas_Direction_Output:
	            uIntVal = 1;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_PIOHWAS_DIRECTION;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, uIntVal);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccPioHwas_Direction_ACN_Decode(asn1SccPioHwas_Direction* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, (&(uIntVal)));
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_PIOHWAS_DIRECTION;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = asn1SccpioHwas_Direction_Input;
	            break;
	        case 1:
	            (*(pVal)) = asn1SccpioHwas_Direction_Output;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_PIOHWAS_DIRECTION;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && asn1SccPioHwas_Direction_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccPioHwasPinConfig_mPinConfig_Equal(const asn1SccPioHwasPinConfig_mPinConfig* pVal1, const asn1SccPioHwasPinConfig_mPinConfig* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag asn1SccPioHwasPinConfig_Equal(const asn1SccPioHwasPinConfig* pVal1, const asn1SccPioHwasPinConfig* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->mPortConfig == pVal2->mPortConfig);

    if (ret) {
        ret = asn1SccPioHwasPinConfig_mPinConfig_Equal((&(pVal1->mPinConfig)), (&(pVal2->mPinConfig)));

        if (ret) {
            ret = (pVal1->mDirectionConfig == pVal2->mDirectionConfig);

        }

    }

	return ret;

}

void asn1SccPioHwasPinConfig_mPinConfig_Initialize(asn1SccPioHwasPinConfig_mPinConfig* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}
void asn1SccPioHwasPinConfig_Initialize(asn1SccPioHwasPinConfig* pVal)
{
	(void)pVal;



	/*set mPortConfig */
	asn1SccPioHwas_Port_Initialize((&(pVal->mPortConfig)));
	/*set mPinConfig */
	asn1SccPioHwasPinConfig_mPinConfig_Initialize((&(pVal->mPinConfig)));
	/*set mDirectionConfig */
	asn1SccPioHwas_Direction_Initialize((&(pVal->mDirectionConfig)));
}

flag asn1SccPioHwasPinConfig_IsConstraintValid(const asn1SccPioHwasPinConfig* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccPioHwas_Port_IsConstraintValid((&(pVal->mPortConfig)), pErrCode);
    if (ret) {
        ret = (pVal->mPinConfig <= 4294967295UL);
        if (ret) {
            ret = (pVal->mPinConfig <= 4294967295UL);
        }
        *pErrCode = ret ? 0 :  ERR_PIOHWASPINCONFIG_MPINCONFIG; 
        if (ret) {
            ret = asn1SccPioHwas_Direction_IsConstraintValid((&(pVal->mDirectionConfig)), pErrCode);
        }
    }

	return ret;
}

flag asn1SccPioHwasPinConfig_Encode(const asn1SccPioHwasPinConfig* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccPioHwasPinConfig_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode mPortConfig */
	    ret = asn1SccPioHwas_Port_Encode((&(pVal->mPortConfig)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode mPinConfig */
	        BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->mPinConfig, 0, 4294967295LL);
	        if (ret) {
	            /*Encode mDirectionConfig */
	            ret = asn1SccPioHwas_Direction_Encode((&(pVal->mDirectionConfig)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccPioHwasPinConfig_Decode(asn1SccPioHwasPinConfig* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode mPortConfig */
	ret = asn1SccPioHwas_Port_Decode((&(pVal->mPortConfig)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode mPinConfig */
	    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->mPinConfig)), 0, 4294967295LL);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_PIOHWASPINCONFIG_MPINCONFIG;
	    if (ret) {
	        /*Decode mDirectionConfig */
	        ret = asn1SccPioHwas_Direction_Decode((&(pVal->mDirectionConfig)), pBitStrm, pErrCode);
	    }
	}

	return ret  && asn1SccPioHwasPinConfig_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccPioHwasPinConfig_ACN_Encode(const asn1SccPioHwasPinConfig* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccPioHwasPinConfig_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode mPortConfig */
	    ret = asn1SccPioHwas_Port_ACN_Encode((&(pVal->mPortConfig)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode mPinConfig */
	        Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, pVal->mPinConfig);
	        if (ret) {
	            /*Encode mDirectionConfig */
	            ret = asn1SccPioHwas_Direction_ACN_Encode((&(pVal->mDirectionConfig)), pBitStrm, pErrCode, FALSE);
	        }

	    }

    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccPioHwasPinConfig_ACN_Decode(asn1SccPioHwasPinConfig* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode mPortConfig */
	ret = asn1SccPioHwas_Port_ACN_Decode((&(pVal->mPortConfig)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode mPinConfig */
	    ret = Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, (&(pVal->mPinConfig)));
	    *pErrCode = ret ? 0 : ERR_ACN_DECODE_PIOHWASPINCONFIG_MPINCONFIG;
	    if (ret) {
	        /*Decode mDirectionConfig */
	        ret = asn1SccPioHwas_Direction_ACN_Decode((&(pVal->mDirectionConfig)), pBitStrm, pErrCode);
	    }

	}


    return ret && asn1SccPioHwasPinConfig_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccMyInteger_Equal(const asn1SccMyInteger* pVal1, const asn1SccMyInteger* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void asn1SccMyInteger_Initialize(asn1SccMyInteger* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccMyInteger_IsConstraintValid(const asn1SccMyInteger* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 10000UL);
    *pErrCode = ret ? 0 :  ERR_MYINTEGER; 

	return ret;
}

flag asn1SccMyInteger_Encode(const asn1SccMyInteger* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccMyInteger_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 10000);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccMyInteger_Decode(asn1SccMyInteger* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 10000);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_MYINTEGER;

	return ret  && asn1SccMyInteger_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccMyInteger_ACN_Encode(const asn1SccMyInteger* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccMyInteger_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 10000);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccMyInteger_ACN_Decode(asn1SccMyInteger* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 10000);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_MYINTEGER;

    return ret && asn1SccMyInteger_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccT_Int32_Equal(const asn1SccT_Int32* pVal1, const asn1SccT_Int32* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void asn1SccT_Int32_Initialize(asn1SccT_Int32* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccT_Int32_IsConstraintValid(const asn1SccT_Int32* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-2147483648LL <= (*(pVal))) && ((*(pVal)) <= 2147483647LL));
    *pErrCode = ret ? 0 :  ERR_T_INT32; 

	return ret;
}

flag asn1SccT_Int32_Encode(const asn1SccT_Int32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Int32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -2147483648LL, 2147483647LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Int32_Decode(asn1SccT_Int32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -2147483648LL, 2147483647LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_INT32;

	return ret  && asn1SccT_Int32_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_Int32_ACN_Encode(const asn1SccT_Int32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Int32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -2147483648LL, 2147483647LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Int32_ACN_Decode(asn1SccT_Int32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -2147483648LL, 2147483647LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_INT32;

    return ret && asn1SccT_Int32_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccT_UInt32_Equal(const asn1SccT_UInt32* pVal1, const asn1SccT_UInt32* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void asn1SccT_UInt32_Initialize(asn1SccT_UInt32* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccT_UInt32_IsConstraintValid(const asn1SccT_UInt32* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 4294967295UL);
    *pErrCode = ret ? 0 :  ERR_T_UINT32; 

	return ret;
}

flag asn1SccT_UInt32_Encode(const asn1SccT_UInt32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_UInt32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_UInt32_Decode(asn1SccT_UInt32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT32;

	return ret  && asn1SccT_UInt32_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_UInt32_ACN_Encode(const asn1SccT_UInt32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_UInt32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_UInt32_ACN_Decode(asn1SccT_UInt32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_UINT32;

    return ret && asn1SccT_UInt32_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccT_Int8_Equal(const asn1SccT_Int8* pVal1, const asn1SccT_Int8* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void asn1SccT_Int8_Initialize(asn1SccT_Int8* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccT_Int8_IsConstraintValid(const asn1SccT_Int8* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-128LL <= (*(pVal))) && ((*(pVal)) <= 127LL));
    *pErrCode = ret ? 0 :  ERR_T_INT8; 

	return ret;
}

flag asn1SccT_Int8_Encode(const asn1SccT_Int8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Int8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -128, 127);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Int8_Decode(asn1SccT_Int8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -128, 127);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_INT8;

	return ret  && asn1SccT_Int8_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_Int8_ACN_Encode(const asn1SccT_Int8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Int8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -128, 127);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Int8_ACN_Decode(asn1SccT_Int8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -128, 127);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_INT8;

    return ret && asn1SccT_Int8_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccT_UInt8_Equal(const asn1SccT_UInt8* pVal1, const asn1SccT_UInt8* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void asn1SccT_UInt8_Initialize(asn1SccT_UInt8* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccT_UInt8_IsConstraintValid(const asn1SccT_UInt8* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_T_UINT8; 

	return ret;
}

flag asn1SccT_UInt8_Encode(const asn1SccT_UInt8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_UInt8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_UInt8_Decode(asn1SccT_UInt8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT8;

	return ret  && asn1SccT_UInt8_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_UInt8_ACN_Encode(const asn1SccT_UInt8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_UInt8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_UInt8_ACN_Decode(asn1SccT_UInt8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_UINT8;

    return ret && asn1SccT_UInt8_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccT_Boolean_Equal(const asn1SccT_Boolean* pVal1, const asn1SccT_Boolean* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

void asn1SccT_Boolean_Initialize(asn1SccT_Boolean* pVal)
{
	(void)pVal;


	(*(pVal)) = FALSE;
}

flag asn1SccT_Boolean_IsConstraintValid(const asn1SccT_Boolean* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

flag asn1SccT_Boolean_Encode(const asn1SccT_Boolean* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Boolean_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_AppendBit(pBitStrm,(*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Boolean_Decode(asn1SccT_Boolean* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_ReadBit(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_BOOLEAN;

	return ret  && asn1SccT_Boolean_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_Boolean_ACN_Encode(const asn1SccT_Boolean* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Boolean_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_AppendBit(pBitStrm,(*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Boolean_ACN_Decode(asn1SccT_Boolean* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_ReadBit(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_BOOLEAN;

    return ret && asn1SccT_Boolean_IsConstraintValid(pVal, pErrCode);
}



flag asn1SccT_Null_Record_Equal(const asn1SccT_Null_Record* pVal1, const asn1SccT_Null_Record* pVal2)
{
	(void)pVal1;
	(void)pVal2;
	return TRUE;

}

void asn1SccT_Null_Record_Initialize(asn1SccT_Null_Record* pVal)
{
	(void)pVal;


}

flag asn1SccT_Null_Record_IsConstraintValid(const asn1SccT_Null_Record* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

flag asn1SccT_Null_Record_Encode(const asn1SccT_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	(void)pBitStrm;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Null_Record_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Null_Record_Decode(asn1SccT_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;
	(void)pBitStrm;



	return ret  && asn1SccT_Null_Record_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccT_Null_Record_ACN_Encode(const asn1SccT_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	(void)pBitStrm;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Null_Record_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Null_Record_ACN_Decode(asn1SccT_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	(void)pBitStrm;
	*pErrCode = 0;



    return ret && asn1SccT_Null_Record_IsConstraintValid(pVal, pErrCode);
}

