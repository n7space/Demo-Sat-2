pragma Style_Checks (Off);
--  Code automatically generated by asn1scc tool
pragma Warnings (Off, "redundant with clause in body");
pragma Warnings (On, "redundant with clause in body");

package body COM_N7SPACE_PIOHWAS with SPARK_Mode is



pragma Warnings (Off, "condition can only be False if invalid values present");
pragma Warnings (Off, "condition can only be True if invalid values present");


function asn1SccDestinationAddress_Equal (val1, val2 :  asn1SccDestinationAddress) return Boolean
is

begin
	return val1 = val2;

end asn1SccDestinationAddress_Equal;

function asn1SccDestinationAddress_Init return asn1SccDestinationAddress
is
    val: asn1SccDestinationAddress;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccDestinationAddress_Init;

function asn1SccDestinationAddress_IsConstraintValid(val : asn1SccDestinationAddress) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (val <= 4294967295);
    ret.ErrorCode := (if ret.Success then 0 else ERR_DESTINATIONADDRESS);
    return ret;
end asn1SccDestinationAddress_IsConstraintValid;



function asn1SccSourceAddress_Equal (val1, val2 :  asn1SccSourceAddress) return Boolean
is

begin
	return val1 = val2;

end asn1SccSourceAddress_Equal;

function asn1SccSourceAddress_Init return asn1SccSourceAddress
is
    val: asn1SccSourceAddress;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccSourceAddress_Init;

function asn1SccSourceAddress_IsConstraintValid(val : asn1SccSourceAddress) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (val <= 4294967295);
    ret.ErrorCode := (if ret.Success then 0 else ERR_SOURCEADDRESS);
    return ret;
end asn1SccSourceAddress_IsConstraintValid;



function asn1SccWord_Equal (val1, val2 :  asn1SccWord) return Boolean
is

begin
	return val1 = val2;

end asn1SccWord_Equal;

function asn1SccWord_Init return asn1SccWord
is
    val: asn1SccWord;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccWord_Init;

function asn1SccWord_IsConstraintValid(val : asn1SccWord) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (val <= 4294967295);
    ret.ErrorCode := (if ret.Success then 0 else ERR_WORD);
    return ret;
end asn1SccWord_IsConstraintValid;



function asn1SccWordMask_Equal (val1, val2 :  asn1SccWordMask) return Boolean
is

begin
	return val1 = val2;

end asn1SccWordMask_Equal;

function asn1SccWordMask_Init return asn1SccWordMask
is
    val: asn1SccWordMask;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccWordMask_Init;

function asn1SccWordMask_IsConstraintValid(val : asn1SccWordMask) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (val <= 4294967295);
    ret.ErrorCode := (if ret.Success then 0 else ERR_WORDMASK);
    return ret;
end asn1SccWordMask_IsConstraintValid;



function asn1SccPioHwas_mPortAddress_Equal (val1, val2 :  asn1SccPioHwas_mPortAddress) return Boolean
is

begin
	return val1 = val2;

end asn1SccPioHwas_mPortAddress_Equal;

function asn1SccPioHwas_mPin_Equal (val1, val2 :  asn1SccPioHwas_mPin) return Boolean
is

begin
	return val1 = val2;

end asn1SccPioHwas_mPin_Equal;

function asn1SccPioHwas_mPortPerAddress_Equal (val1, val2 :  asn1SccPioHwas_mPortPerAddress) return Boolean
is

begin
	return val1 = val2;

end asn1SccPioHwas_mPortPerAddress_Equal;

function asn1SccPioHwas_mPortOerAddress_Equal (val1, val2 :  asn1SccPioHwas_mPortOerAddress) return Boolean
is

begin
	return val1 = val2;

end asn1SccPioHwas_mPortOerAddress_Equal;

function asn1SccPioHwas_mPortOdrAddress_Equal (val1, val2 :  asn1SccPioHwas_mPortOdrAddress) return Boolean
is

begin
	return val1 = val2;

end asn1SccPioHwas_mPortOdrAddress_Equal;

function asn1SccPioHwas_mPortIfdrAddress_Equal (val1, val2 :  asn1SccPioHwas_mPortIfdrAddress) return Boolean
is

begin
	return val1 = val2;

end asn1SccPioHwas_mPortIfdrAddress_Equal;

function asn1SccPioHwas_mPortSodrAddress_Equal (val1, val2 :  asn1SccPioHwas_mPortSodrAddress) return Boolean
is

begin
	return val1 = val2;

end asn1SccPioHwas_mPortSodrAddress_Equal;

function asn1SccPioHwas_mPortCodrAddress_Equal (val1, val2 :  asn1SccPioHwas_mPortCodrAddress) return Boolean
is

begin
	return val1 = val2;

end asn1SccPioHwas_mPortCodrAddress_Equal;

function asn1SccPioHwas_mPortMddrAddress_Equal (val1, val2 :  asn1SccPioHwas_mPortMddrAddress) return Boolean
is

begin
	return val1 = val2;

end asn1SccPioHwas_mPortMddrAddress_Equal;

function asn1SccPioHwas_mPortPudrAddress_Equal (val1, val2 :  asn1SccPioHwas_mPortPudrAddress) return Boolean
is

begin
	return val1 = val2;

end asn1SccPioHwas_mPortPudrAddress_Equal;

function asn1SccPioHwas_mPortOwerAddress_Equal (val1, val2 :  asn1SccPioHwas_mPortOwerAddress) return Boolean
is

begin
	return val1 = val2;

end asn1SccPioHwas_mPortOwerAddress_Equal;

function asn1SccPioHwas_mPortOwdrAddress_Equal (val1, val2 :  asn1SccPioHwas_mPortOwdrAddress) return Boolean
is

begin
	return val1 = val2;

end asn1SccPioHwas_mPortOwdrAddress_Equal;

function asn1SccPioHwas_mPortIfscdrAddress_Equal (val1, val2 :  asn1SccPioHwas_mPortIfscdrAddress) return Boolean
is

begin
	return val1 = val2;

end asn1SccPioHwas_mPortIfscdrAddress_Equal;

function asn1SccPioHwas_mPortPpddrAddress_Equal (val1, val2 :  asn1SccPioHwas_mPortPpddrAddress) return Boolean
is

begin
	return val1 = val2;

end asn1SccPioHwas_mPortPpddrAddress_Equal;

function asn1SccPioHwas_mPortSchmittAddress_Equal (val1, val2 :  asn1SccPioHwas_mPortSchmittAddress) return Boolean
is

begin
	return val1 = val2;

end asn1SccPioHwas_mPortSchmittAddress_Equal;

function asn1SccPioHwas_Equal (val1, val2 :  asn1SccPioHwas) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := asn1SccPioHwas_mPortAddress_Equal(val1.mPortAddress, val2.mPortAddress);

    if ret then
        ret := asn1SccPioHwas_mPin_Equal(val1.mPin, val2.mPin);

        if ret then
            ret := asn1SccPioHwas_mPortPerAddress_Equal(val1.mPortPerAddress, val2.mPortPerAddress);

            if ret then
                ret := asn1SccPioHwas_mPortOerAddress_Equal(val1.mPortOerAddress, val2.mPortOerAddress);

                if ret then
                    ret := asn1SccPioHwas_mPortOdrAddress_Equal(val1.mPortOdrAddress, val2.mPortOdrAddress);

                    if ret then
                        ret := asn1SccPioHwas_mPortIfdrAddress_Equal(val1.mPortIfdrAddress, val2.mPortIfdrAddress);

                        if ret then
                            ret := asn1SccPioHwas_mPortSodrAddress_Equal(val1.mPortSodrAddress, val2.mPortSodrAddress);

                            if ret then
                                ret := asn1SccPioHwas_mPortCodrAddress_Equal(val1.mPortCodrAddress, val2.mPortCodrAddress);

                                if ret then
                                    ret := asn1SccPioHwas_mPortMddrAddress_Equal(val1.mPortMddrAddress, val2.mPortMddrAddress);

                                    if ret then
                                        ret := asn1SccPioHwas_mPortPudrAddress_Equal(val1.mPortPudrAddress, val2.mPortPudrAddress);

                                        if ret then
                                            ret := asn1SccPioHwas_mPortOwerAddress_Equal(val1.mPortOwerAddress, val2.mPortOwerAddress);

                                            if ret then
                                                ret := asn1SccPioHwas_mPortOwdrAddress_Equal(val1.mPortOwdrAddress, val2.mPortOwdrAddress);

                                                if ret then
                                                    ret := asn1SccPioHwas_mPortIfscdrAddress_Equal(val1.mPortIfscdrAddress, val2.mPortIfscdrAddress);

                                                    if ret then
                                                        ret := asn1SccPioHwas_mPortPpddrAddress_Equal(val1.mPortPpddrAddress, val2.mPortPpddrAddress);

                                                        if ret then
                                                            ret := asn1SccPioHwas_mPortSchmittAddress_Equal(val1.mPortSchmittAddress, val2.mPortSchmittAddress);

                                                        end if;
                                                    end if;
                                                end if;
                                            end if;
                                        end if;
                                    end if;
                                end if;
                            end if;
                        end if;
                    end if;
                end if;
            end if;
        end if;
    end if;
	return ret;

end asn1SccPioHwas_Equal;

function asn1SccPioHwas_mPortAddress_Init return asn1SccPioHwas_mPortAddress
is
    val: asn1SccPioHwas_mPortAddress;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPioHwas_mPortAddress_Init;
function asn1SccPioHwas_mPin_Init return asn1SccPioHwas_mPin
is
    val: asn1SccPioHwas_mPin;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPioHwas_mPin_Init;
function asn1SccPioHwas_mPortPerAddress_Init return asn1SccPioHwas_mPortPerAddress
is
    val: asn1SccPioHwas_mPortPerAddress;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPioHwas_mPortPerAddress_Init;
function asn1SccPioHwas_mPortOerAddress_Init return asn1SccPioHwas_mPortOerAddress
is
    val: asn1SccPioHwas_mPortOerAddress;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPioHwas_mPortOerAddress_Init;
function asn1SccPioHwas_mPortOdrAddress_Init return asn1SccPioHwas_mPortOdrAddress
is
    val: asn1SccPioHwas_mPortOdrAddress;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPioHwas_mPortOdrAddress_Init;
function asn1SccPioHwas_mPortIfdrAddress_Init return asn1SccPioHwas_mPortIfdrAddress
is
    val: asn1SccPioHwas_mPortIfdrAddress;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPioHwas_mPortIfdrAddress_Init;
function asn1SccPioHwas_mPortSodrAddress_Init return asn1SccPioHwas_mPortSodrAddress
is
    val: asn1SccPioHwas_mPortSodrAddress;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPioHwas_mPortSodrAddress_Init;
function asn1SccPioHwas_mPortCodrAddress_Init return asn1SccPioHwas_mPortCodrAddress
is
    val: asn1SccPioHwas_mPortCodrAddress;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPioHwas_mPortCodrAddress_Init;
function asn1SccPioHwas_mPortMddrAddress_Init return asn1SccPioHwas_mPortMddrAddress
is
    val: asn1SccPioHwas_mPortMddrAddress;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPioHwas_mPortMddrAddress_Init;
function asn1SccPioHwas_mPortPudrAddress_Init return asn1SccPioHwas_mPortPudrAddress
is
    val: asn1SccPioHwas_mPortPudrAddress;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPioHwas_mPortPudrAddress_Init;
function asn1SccPioHwas_mPortOwerAddress_Init return asn1SccPioHwas_mPortOwerAddress
is
    val: asn1SccPioHwas_mPortOwerAddress;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPioHwas_mPortOwerAddress_Init;
function asn1SccPioHwas_mPortOwdrAddress_Init return asn1SccPioHwas_mPortOwdrAddress
is
    val: asn1SccPioHwas_mPortOwdrAddress;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPioHwas_mPortOwdrAddress_Init;
function asn1SccPioHwas_mPortIfscdrAddress_Init return asn1SccPioHwas_mPortIfscdrAddress
is
    val: asn1SccPioHwas_mPortIfscdrAddress;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPioHwas_mPortIfscdrAddress_Init;
function asn1SccPioHwas_mPortPpddrAddress_Init return asn1SccPioHwas_mPortPpddrAddress
is
    val: asn1SccPioHwas_mPortPpddrAddress;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPioHwas_mPortPpddrAddress_Init;
function asn1SccPioHwas_mPortSchmittAddress_Init return asn1SccPioHwas_mPortSchmittAddress
is
    val: asn1SccPioHwas_mPortSchmittAddress;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPioHwas_mPortSchmittAddress_Init;
function asn1SccPioHwas_Init return asn1SccPioHwas
is
    val: asn1SccPioHwas;
begin

    --set mPortAddress 
    val.mPortAddress := asn1SccPioHwas_mPortAddress_Init;
    --set mPin 
    val.mPin := asn1SccPioHwas_mPin_Init;
    --set mPortPerAddress 
    val.mPortPerAddress := asn1SccPioHwas_mPortPerAddress_Init;
    --set mPortOerAddress 
    val.mPortOerAddress := asn1SccPioHwas_mPortOerAddress_Init;
    --set mPortOdrAddress 
    val.mPortOdrAddress := asn1SccPioHwas_mPortOdrAddress_Init;
    --set mPortIfdrAddress 
    val.mPortIfdrAddress := asn1SccPioHwas_mPortIfdrAddress_Init;
    --set mPortSodrAddress 
    val.mPortSodrAddress := asn1SccPioHwas_mPortSodrAddress_Init;
    --set mPortCodrAddress 
    val.mPortCodrAddress := asn1SccPioHwas_mPortCodrAddress_Init;
    --set mPortMddrAddress 
    val.mPortMddrAddress := asn1SccPioHwas_mPortMddrAddress_Init;
    --set mPortPudrAddress 
    val.mPortPudrAddress := asn1SccPioHwas_mPortPudrAddress_Init;
    --set mPortOwerAddress 
    val.mPortOwerAddress := asn1SccPioHwas_mPortOwerAddress_Init;
    --set mPortOwdrAddress 
    val.mPortOwdrAddress := asn1SccPioHwas_mPortOwdrAddress_Init;
    --set mPortIfscdrAddress 
    val.mPortIfscdrAddress := asn1SccPioHwas_mPortIfscdrAddress_Init;
    --set mPortPpddrAddress 
    val.mPortPpddrAddress := asn1SccPioHwas_mPortPpddrAddress_Init;
    --set mPortSchmittAddress 
    val.mPortSchmittAddress := asn1SccPioHwas_mPortSchmittAddress_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPioHwas_Init;

function asn1SccPioHwas_IsConstraintValid(val : asn1SccPioHwas) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (val.mPortAddress <= 4294967295);
    if ret.Success then
        ret.Success := (val.mPortAddress <= 4294967295);
    end if;
    ret.ErrorCode := (if ret.Success then 0 else ERR_PIOHWAS_MPORTADDRESS);
    if ret.Success then
        ret.Success := (val.mPin <= 4294967295);
        if ret.Success then
            ret.Success := (val.mPin <= 4294967295);
        end if;
        ret.ErrorCode := (if ret.Success then 0 else ERR_PIOHWAS_MPIN);
        if ret.Success then
            ret.Success := (val.mPortPerAddress <= 4294967295);
            if ret.Success then
                ret.Success := (val.mPortPerAddress <= 4294967295);
            end if;
            ret.ErrorCode := (if ret.Success then 0 else ERR_PIOHWAS_MPORTPERADDRESS);
            if ret.Success then
                ret.Success := (val.mPortOerAddress <= 4294967295);
                if ret.Success then
                    ret.Success := (val.mPortOerAddress <= 4294967295);
                end if;
                ret.ErrorCode := (if ret.Success then 0 else ERR_PIOHWAS_MPORTOERADDRESS);
                if ret.Success then
                    ret.Success := (val.mPortOdrAddress <= 4294967295);
                    if ret.Success then
                        ret.Success := (val.mPortOdrAddress <= 4294967295);
                    end if;
                    ret.ErrorCode := (if ret.Success then 0 else ERR_PIOHWAS_MPORTODRADDRESS);
                    if ret.Success then
                        ret.Success := (val.mPortIfdrAddress <= 4294967295);
                        if ret.Success then
                            ret.Success := (val.mPortIfdrAddress <= 4294967295);
                        end if;
                        ret.ErrorCode := (if ret.Success then 0 else ERR_PIOHWAS_MPORTIFDRADDRESS);
                        if ret.Success then
                            ret.Success := (val.mPortSodrAddress <= 4294967295);
                            if ret.Success then
                                ret.Success := (val.mPortSodrAddress <= 4294967295);
                            end if;
                            ret.ErrorCode := (if ret.Success then 0 else ERR_PIOHWAS_MPORTSODRADDRESS);
                            if ret.Success then
                                ret.Success := (val.mPortCodrAddress <= 4294967295);
                                if ret.Success then
                                    ret.Success := (val.mPortCodrAddress <= 4294967295);
                                end if;
                                ret.ErrorCode := (if ret.Success then 0 else ERR_PIOHWAS_MPORTCODRADDRESS);
                                if ret.Success then
                                    ret.Success := (val.mPortMddrAddress <= 4294967295);
                                    if ret.Success then
                                        ret.Success := (val.mPortMddrAddress <= 4294967295);
                                    end if;
                                    ret.ErrorCode := (if ret.Success then 0 else ERR_PIOHWAS_MPORTMDDRADDRESS);
                                    if ret.Success then
                                        ret.Success := (val.mPortPudrAddress <= 4294967295);
                                        if ret.Success then
                                            ret.Success := (val.mPortPudrAddress <= 4294967295);
                                        end if;
                                        ret.ErrorCode := (if ret.Success then 0 else ERR_PIOHWAS_MPORTPUDRADDRESS);
                                        if ret.Success then
                                            ret.Success := (val.mPortOwerAddress <= 4294967295);
                                            if ret.Success then
                                                ret.Success := (val.mPortOwerAddress <= 4294967295);
                                            end if;
                                            ret.ErrorCode := (if ret.Success then 0 else ERR_PIOHWAS_MPORTOWERADDRESS);
                                            if ret.Success then
                                                ret.Success := (val.mPortOwdrAddress <= 4294967295);
                                                if ret.Success then
                                                    ret.Success := (val.mPortOwdrAddress <= 4294967295);
                                                end if;
                                                ret.ErrorCode := (if ret.Success then 0 else ERR_PIOHWAS_MPORTOWDRADDRESS);
                                                if ret.Success then
                                                    ret.Success := (val.mPortIfscdrAddress <= 4294967295);
                                                    if ret.Success then
                                                        ret.Success := (val.mPortIfscdrAddress <= 4294967295);
                                                    end if;
                                                    ret.ErrorCode := (if ret.Success then 0 else ERR_PIOHWAS_MPORTIFSCDRADDRESS);
                                                    if ret.Success then
                                                        ret.Success := (val.mPortPpddrAddress <= 4294967295);
                                                        if ret.Success then
                                                            ret.Success := (val.mPortPpddrAddress <= 4294967295);
                                                        end if;
                                                        ret.ErrorCode := (if ret.Success then 0 else ERR_PIOHWAS_MPORTPPDDRADDRESS);
                                                        if ret.Success then
                                                            ret.Success := (val.mPortSchmittAddress <= 4294967295);
                                                            if ret.Success then
                                                                ret.Success := (val.mPortSchmittAddress <= 4294967295);
                                                            end if;
                                                            ret.ErrorCode := (if ret.Success then 0 else ERR_PIOHWAS_MPORTSCHMITTADDRESS);
                                                        end if;
                                                    end if;
                                                end if;
                                            end if;
                                        end if;
                                    end if;
                                end if;
                            end if;
                        end if;
                    end if;
                end if;
            end if;
        end if;
    end if;
    return ret;
end asn1SccPioHwas_IsConstraintValid;



function asn1SccPmcHwas_pMC_PCSR0_OFFSET_Equal (val1, val2 :  asn1SccPmcHwas_pMC_PCSR0_OFFSET) return Boolean
is

begin
	return val1 = val2;

end asn1SccPmcHwas_pMC_PCSR0_OFFSET_Equal;

function asn1SccPmcHwas_pMC_PCxR0_PID10_PIOA_MASK_Equal (val1, val2 :  asn1SccPmcHwas_pMC_PCxR0_PID10_PIOA_MASK) return Boolean
is

begin
	return val1 = val2;

end asn1SccPmcHwas_pMC_PCxR0_PID10_PIOA_MASK_Equal;

function asn1SccPmcHwas_pMC_PCxR0_PID11_PIOB_MASK_Equal (val1, val2 :  asn1SccPmcHwas_pMC_PCxR0_PID11_PIOB_MASK) return Boolean
is

begin
	return val1 = val2;

end asn1SccPmcHwas_pMC_PCxR0_PID11_PIOB_MASK_Equal;

function asn1SccPmcHwas_pMC_PCxR0_PID12_PIOC_MASK_Equal (val1, val2 :  asn1SccPmcHwas_pMC_PCxR0_PID12_PIOC_MASK) return Boolean
is

begin
	return val1 = val2;

end asn1SccPmcHwas_pMC_PCxR0_PID12_PIOC_MASK_Equal;

function asn1SccPmcHwas_pMC_PCxR0_PID16_PIOD_MASK_Equal (val1, val2 :  asn1SccPmcHwas_pMC_PCxR0_PID16_PIOD_MASK) return Boolean
is

begin
	return val1 = val2;

end asn1SccPmcHwas_pMC_PCxR0_PID16_PIOD_MASK_Equal;

function asn1SccPmcHwas_pMC_PCxR0_PID17_PIOE_MASK_Equal (val1, val2 :  asn1SccPmcHwas_pMC_PCxR0_PID17_PIOE_MASK) return Boolean
is

begin
	return val1 = val2;

end asn1SccPmcHwas_pMC_PCxR0_PID17_PIOE_MASK_Equal;

function asn1SccPmcHwas_Equal (val1, val2 :  asn1SccPmcHwas) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := asn1SccPmcHwas_pMC_PCSR0_OFFSET_Equal(val1.pMC_PCSR0_OFFSET, val2.pMC_PCSR0_OFFSET);

    if ret then
        ret := asn1SccPmcHwas_pMC_PCxR0_PID10_PIOA_MASK_Equal(val1.pMC_PCxR0_PID10_PIOA_MASK, val2.pMC_PCxR0_PID10_PIOA_MASK);

        if ret then
            ret := asn1SccPmcHwas_pMC_PCxR0_PID11_PIOB_MASK_Equal(val1.pMC_PCxR0_PID11_PIOB_MASK, val2.pMC_PCxR0_PID11_PIOB_MASK);

            if ret then
                ret := asn1SccPmcHwas_pMC_PCxR0_PID12_PIOC_MASK_Equal(val1.pMC_PCxR0_PID12_PIOC_MASK, val2.pMC_PCxR0_PID12_PIOC_MASK);

                if ret then
                    ret := asn1SccPmcHwas_pMC_PCxR0_PID16_PIOD_MASK_Equal(val1.pMC_PCxR0_PID16_PIOD_MASK, val2.pMC_PCxR0_PID16_PIOD_MASK);

                    if ret then
                        ret := asn1SccPmcHwas_pMC_PCxR0_PID17_PIOE_MASK_Equal(val1.pMC_PCxR0_PID17_PIOE_MASK, val2.pMC_PCxR0_PID17_PIOE_MASK);

                    end if;
                end if;
            end if;
        end if;
    end if;
	return ret;

end asn1SccPmcHwas_Equal;

function asn1SccPmcHwas_pMC_PCSR0_OFFSET_Init return asn1SccPmcHwas_pMC_PCSR0_OFFSET
is
    val: asn1SccPmcHwas_pMC_PCSR0_OFFSET;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPmcHwas_pMC_PCSR0_OFFSET_Init;
function asn1SccPmcHwas_pMC_PCxR0_PID10_PIOA_MASK_Init return asn1SccPmcHwas_pMC_PCxR0_PID10_PIOA_MASK
is
    val: asn1SccPmcHwas_pMC_PCxR0_PID10_PIOA_MASK;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPmcHwas_pMC_PCxR0_PID10_PIOA_MASK_Init;
function asn1SccPmcHwas_pMC_PCxR0_PID11_PIOB_MASK_Init return asn1SccPmcHwas_pMC_PCxR0_PID11_PIOB_MASK
is
    val: asn1SccPmcHwas_pMC_PCxR0_PID11_PIOB_MASK;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPmcHwas_pMC_PCxR0_PID11_PIOB_MASK_Init;
function asn1SccPmcHwas_pMC_PCxR0_PID12_PIOC_MASK_Init return asn1SccPmcHwas_pMC_PCxR0_PID12_PIOC_MASK
is
    val: asn1SccPmcHwas_pMC_PCxR0_PID12_PIOC_MASK;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPmcHwas_pMC_PCxR0_PID12_PIOC_MASK_Init;
function asn1SccPmcHwas_pMC_PCxR0_PID16_PIOD_MASK_Init return asn1SccPmcHwas_pMC_PCxR0_PID16_PIOD_MASK
is
    val: asn1SccPmcHwas_pMC_PCxR0_PID16_PIOD_MASK;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPmcHwas_pMC_PCxR0_PID16_PIOD_MASK_Init;
function asn1SccPmcHwas_pMC_PCxR0_PID17_PIOE_MASK_Init return asn1SccPmcHwas_pMC_PCxR0_PID17_PIOE_MASK
is
    val: asn1SccPmcHwas_pMC_PCxR0_PID17_PIOE_MASK;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPmcHwas_pMC_PCxR0_PID17_PIOE_MASK_Init;
function asn1SccPmcHwas_Init return asn1SccPmcHwas
is
    val: asn1SccPmcHwas;
begin

    --set pMC_PCSR0_OFFSET 
    val.pMC_PCSR0_OFFSET := asn1SccPmcHwas_pMC_PCSR0_OFFSET_Init;
    --set pMC_PCxR0_PID10_PIOA_MASK 
    val.pMC_PCxR0_PID10_PIOA_MASK := asn1SccPmcHwas_pMC_PCxR0_PID10_PIOA_MASK_Init;
    --set pMC_PCxR0_PID11_PIOB_MASK 
    val.pMC_PCxR0_PID11_PIOB_MASK := asn1SccPmcHwas_pMC_PCxR0_PID11_PIOB_MASK_Init;
    --set pMC_PCxR0_PID12_PIOC_MASK 
    val.pMC_PCxR0_PID12_PIOC_MASK := asn1SccPmcHwas_pMC_PCxR0_PID12_PIOC_MASK_Init;
    --set pMC_PCxR0_PID16_PIOD_MASK 
    val.pMC_PCxR0_PID16_PIOD_MASK := asn1SccPmcHwas_pMC_PCxR0_PID16_PIOD_MASK_Init;
    --set pMC_PCxR0_PID17_PIOE_MASK 
    val.pMC_PCxR0_PID17_PIOE_MASK := asn1SccPmcHwas_pMC_PCxR0_PID17_PIOE_MASK_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPmcHwas_Init;

function asn1SccPmcHwas_IsConstraintValid(val : asn1SccPmcHwas) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (val.pMC_PCSR0_OFFSET <= 4294967295);
    if ret.Success then
        ret.Success := (val.pMC_PCSR0_OFFSET <= 4294967295);
    end if;
    ret.ErrorCode := (if ret.Success then 0 else ERR_PMCHWAS_PMC_PCSR0_OFFSET);
    if ret.Success then
        ret.Success := (val.pMC_PCxR0_PID10_PIOA_MASK <= 4294967295);
        if ret.Success then
            ret.Success := (val.pMC_PCxR0_PID10_PIOA_MASK <= 4294967295);
        end if;
        ret.ErrorCode := (if ret.Success then 0 else ERR_PMCHWAS_PMC_PCXR0_PID10_PIOA_MASK);
        if ret.Success then
            ret.Success := (val.pMC_PCxR0_PID11_PIOB_MASK <= 4294967295);
            if ret.Success then
                ret.Success := (val.pMC_PCxR0_PID11_PIOB_MASK <= 4294967295);
            end if;
            ret.ErrorCode := (if ret.Success then 0 else ERR_PMCHWAS_PMC_PCXR0_PID11_PIOB_MASK);
            if ret.Success then
                ret.Success := (val.pMC_PCxR0_PID12_PIOC_MASK <= 4294967295);
                if ret.Success then
                    ret.Success := (val.pMC_PCxR0_PID12_PIOC_MASK <= 4294967295);
                end if;
                ret.ErrorCode := (if ret.Success then 0 else ERR_PMCHWAS_PMC_PCXR0_PID12_PIOC_MASK);
                if ret.Success then
                    ret.Success := (val.pMC_PCxR0_PID16_PIOD_MASK <= 4294967295);
                    if ret.Success then
                        ret.Success := (val.pMC_PCxR0_PID16_PIOD_MASK <= 4294967295);
                    end if;
                    ret.ErrorCode := (if ret.Success then 0 else ERR_PMCHWAS_PMC_PCXR0_PID16_PIOD_MASK);
                    if ret.Success then
                        ret.Success := (val.pMC_PCxR0_PID17_PIOE_MASK <= 4294967295);
                        if ret.Success then
                            ret.Success := (val.pMC_PCxR0_PID17_PIOE_MASK <= 4294967295);
                        end if;
                        ret.ErrorCode := (if ret.Success then 0 else ERR_PMCHWAS_PMC_PCXR0_PID17_PIOE_MASK);
                    end if;
                end if;
            end if;
        end if;
    end if;
    return ret;
end asn1SccPmcHwas_IsConstraintValid;



function asn1SccBufferSize_Equal (val1, val2 :  asn1SccBufferSize) return Boolean
is

begin
	return val1 = val2;

end asn1SccBufferSize_Equal;

function asn1SccBufferSize_Init return asn1SccBufferSize
is
    val: asn1SccBufferSize;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccBufferSize_Init;

function asn1SccBufferSize_IsConstraintValid(val : asn1SccBufferSize) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (val <= 65535);
    ret.ErrorCode := (if ret.Success then 0 else ERR_BUFFERSIZE);
    return ret;
end asn1SccBufferSize_IsConstraintValid;



function asn1SccInterruptNumber_Equal (val1, val2 :  asn1SccInterruptNumber) return Boolean
is

begin
	return val1 = val2;

end asn1SccInterruptNumber_Equal;

function asn1SccInterruptNumber_Init return asn1SccInterruptNumber
is
    val: asn1SccInterruptNumber;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccInterruptNumber_Init;

function asn1SccInterruptNumber_IsConstraintValid(val : asn1SccInterruptNumber) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (val <= 255);
    ret.ErrorCode := (if ret.Success then 0 else ERR_INTERRUPTNUMBER);
    return ret;
end asn1SccInterruptNumber_IsConstraintValid;



function asn1SccByte_Equal (val1, val2 :  asn1SccByte) return Boolean
is

begin
	return val1 = val2;

end asn1SccByte_Equal;

function asn1SccByte_Init return asn1SccByte
is
    val: asn1SccByte;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccByte_Init;

function asn1SccByte_IsConstraintValid(val : asn1SccByte) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (val <= 255);
    ret.ErrorCode := (if ret.Success then 0 else ERR_BYTE);
    return ret;
end asn1SccByte_IsConstraintValid;



function asn1SccByteBuffer_elem_Equal (val1, val2 :  asn1SccByteBuffer_elem) return Boolean
is

begin
	return val1 = val2;

end asn1SccByteBuffer_elem_Equal;

function asn1SccByteBuffer_Equal (val1, val2 :  asn1SccByteBuffer) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := asn1SccByteBuffer_elem_Equal(val1.Data(i1), val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end asn1SccByteBuffer_Equal;

function asn1SccByteBuffer_elem_Init return asn1SccByteBuffer_elem
is
    val: asn1SccByteBuffer_elem;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccByteBuffer_elem_Init;
function asn1SccByteBuffer_Init return asn1SccByteBuffer
is
    val: asn1SccByteBuffer;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 65535 loop
        --  commented because it casues this warning    
        --  warning: condition can only be False if invalid values present
        pragma Loop_Invariant (i1 >=1 and i1<=65535);
        val.Data(i1) := asn1SccByteBuffer_elem_Init;
        i1 := i1 + 1;
    end loop;
    val.Length := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccByteBuffer_Init;

function asn1SccByteBuffer_IsConstraintValid(val : asn1SccByteBuffer) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
begin
    ret.Success := (val.Length <= 65535);
    ret.ErrorCode := (if ret.Success then 0 else ERR_BYTEBUFFER);
    if ret.Success then
        i1 := val.Data'First;
        while ret.Success and i1 <= val.Length loop
            pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
            ret.Success := (val.Data(i1) <= 255);
            if ret.Success then
                ret.Success := (val.Data(i1) <= 255);
            end if;
            ret.ErrorCode := (if ret.Success then 0 else ERR_BYTEBUFFER_ELM);
            i1 := i1+1;
        end loop;
    end if;
    return ret;
end asn1SccByteBuffer_IsConstraintValid;



function asn1SccPinNumber_Equal (val1, val2 :  asn1SccPinNumber) return Boolean
is

begin
	return val1 = val2;

end asn1SccPinNumber_Equal;

function asn1SccPinNumber_Init return asn1SccPinNumber
is
    val: asn1SccPinNumber;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPinNumber_Init;

function asn1SccPinNumber_IsConstraintValid(val : asn1SccPinNumber) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (val <= 64);
    ret.ErrorCode := (if ret.Success then 0 else ERR_PINNUMBER);
    return ret;
end asn1SccPinNumber_IsConstraintValid;



function asn1SccPioHwas_Port_Equal (val1, val2 :  asn1SccPioHwas_Port) return Boolean
is

begin
	return val1 = val2;

end asn1SccPioHwas_Port_Equal;

function asn1SccPioHwas_Port_Init return asn1SccPioHwas_Port
is
    val: asn1SccPioHwas_Port;
begin
    val := asn1SccpioHwas_Port_A;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPioHwas_Port_Init;

function asn1SccPioHwas_Port_IsConstraintValid(val : asn1SccPioHwas_Port) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (((((((((val = asn1SccpioHwas_Port_A)) OR ((val = asn1SccpioHwas_Port_B)))) OR ((val = asn1SccpioHwas_Port_C)))) OR ((val = asn1SccpioHwas_Port_D)))) OR ((val = asn1SccpioHwas_Port_E)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_PIOHWAS_PORT);
    return ret;
end asn1SccPioHwas_Port_IsConstraintValid;



function asn1SccPioHwas_Direction_Equal (val1, val2 :  asn1SccPioHwas_Direction) return Boolean
is

begin
	return val1 = val2;

end asn1SccPioHwas_Direction_Equal;

function asn1SccPioHwas_Direction_Init return asn1SccPioHwas_Direction
is
    val: asn1SccPioHwas_Direction;
begin
    val := asn1SccpioHwas_Direction_Input;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPioHwas_Direction_Init;

function asn1SccPioHwas_Direction_IsConstraintValid(val : asn1SccPioHwas_Direction) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (((val = asn1SccpioHwas_Direction_Input)) OR ((val = asn1SccpioHwas_Direction_Output)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_PIOHWAS_DIRECTION);
    return ret;
end asn1SccPioHwas_Direction_IsConstraintValid;



function asn1SccPioHwasPinConfig_mPinConfig_Equal (val1, val2 :  asn1SccPioHwasPinConfig_mPinConfig) return Boolean
is

begin
	return val1 = val2;

end asn1SccPioHwasPinConfig_mPinConfig_Equal;

function asn1SccPioHwasPinConfig_Equal (val1, val2 :  asn1SccPioHwasPinConfig) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := (val1.mPortConfig = val2.mPortConfig);

    if ret then
        ret := asn1SccPioHwasPinConfig_mPinConfig_Equal(val1.mPinConfig, val2.mPinConfig);

        if ret then
            ret := (val1.mDirectionConfig = val2.mDirectionConfig);

        end if;
    end if;
	return ret;

end asn1SccPioHwasPinConfig_Equal;

function asn1SccPioHwasPinConfig_mPinConfig_Init return asn1SccPioHwasPinConfig_mPinConfig
is
    val: asn1SccPioHwasPinConfig_mPinConfig;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPioHwasPinConfig_mPinConfig_Init;
function asn1SccPioHwasPinConfig_Init return asn1SccPioHwasPinConfig
is
    val: asn1SccPioHwasPinConfig;
begin

    --set mPortConfig 
    val.mPortConfig := asn1SccPioHwas_Port_Init;
    --set mPinConfig 
    val.mPinConfig := asn1SccPioHwasPinConfig_mPinConfig_Init;
    --set mDirectionConfig 
    val.mDirectionConfig := asn1SccPioHwas_Direction_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPioHwasPinConfig_Init;

function asn1SccPioHwasPinConfig_IsConstraintValid(val : asn1SccPioHwasPinConfig) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := asn1SccPioHwas_Port_IsConstraintValid(val.mPortConfig);
    if ret.Success then
        ret.Success := (val.mPinConfig <= 4294967295);
        if ret.Success then
            ret.Success := (val.mPinConfig <= 4294967295);
        end if;
        ret.ErrorCode := (if ret.Success then 0 else ERR_PIOHWASPINCONFIG_MPINCONFIG);
        if ret.Success then
            ret := asn1SccPioHwas_Direction_IsConstraintValid(val.mDirectionConfig);
        end if;
    end if;
    return ret;
end asn1SccPioHwasPinConfig_IsConstraintValid;


pragma Warnings (On, "condition can only be False if invalid values present");
pragma Warnings (On, "condition can only be True if invalid values present");

 
end COM_N7SPACE_PIOHWAS;