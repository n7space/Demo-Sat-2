pragma Style_Checks (Off);
--  Code automatically generated by asn1scc tool
pragma Warnings (Off, "redundant with clause in body");
pragma Warnings (On, "redundant with clause in body");

package body COM_N7SPACE_HWAS with SPARK_Mode is



pragma Warnings (Off, "condition can only be False if invalid values present");
pragma Warnings (Off, "condition can only be True if invalid values present");


function asn1SccInterruptNumber_Equal (val1, val2 :  asn1SccInterruptNumber) return Boolean
is

begin
	return val1 = val2;

end asn1SccInterruptNumber_Equal;

function asn1SccInterruptNumber_Init return asn1SccInterruptNumber
is
    val: asn1SccInterruptNumber;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccInterruptNumber_Init;

function asn1SccInterruptNumber_IsConstraintValid(val : asn1SccInterruptNumber) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (val <= 255);
    ret.ErrorCode := (if ret.Success then 0 else ERR_INTERRUPTNUMBER);
    return ret;
end asn1SccInterruptNumber_IsConstraintValid;



function asn1SccInterrupt_Type_interrupt_Equal (val1, val2 :  asn1SccInterrupt_Type_interrupt) return Boolean
is

begin
	return val1 = val2;

end asn1SccInterrupt_Type_interrupt_Equal;

function asn1SccInterrupt_Type_Equal (val1, val2 :  asn1SccInterrupt_Type) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");

begin
    ret := asn1SccInterrupt_Type_interrupt_Equal(val1.interrupt, val2.interrupt);

	return ret;

end asn1SccInterrupt_Type_Equal;

function asn1SccInterrupt_Type_interrupt_Init return asn1SccInterrupt_Type_interrupt
is
    val: asn1SccInterrupt_Type_interrupt;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccInterrupt_Type_interrupt_Init;
function asn1SccInterrupt_Type_Init return asn1SccInterrupt_Type
is
    val: asn1SccInterrupt_Type;
begin

    --set interrupt 
    val.interrupt := asn1SccInterrupt_Type_interrupt_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccInterrupt_Type_Init;

function asn1SccInterrupt_Type_IsConstraintValid(val : asn1SccInterrupt_Type) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (val.interrupt <= 255);
    if ret.Success then
        ret.Success := (val.interrupt <= 255);
    end if;
    ret.ErrorCode := (if ret.Success then 0 else ERR_INTERRUPT_TYPE_INTERRUPT);
    return ret;
end asn1SccInterrupt_Type_IsConstraintValid;



function asn1SccByte_Equal (val1, val2 :  asn1SccByte) return Boolean
is

begin
	return val1 = val2;

end asn1SccByte_Equal;

function asn1SccByte_Init return asn1SccByte
is
    val: asn1SccByte;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccByte_Init;

function asn1SccByte_IsConstraintValid(val : asn1SccByte) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret.Success := (val <= 255);
    ret.ErrorCode := (if ret.Success then 0 else ERR_BYTE);
    return ret;
end asn1SccByte_IsConstraintValid;



function asn1SccByteBuffer_elem_Equal (val1, val2 :  asn1SccByteBuffer_elem) return Boolean
is

begin
	return val1 = val2;

end asn1SccByteBuffer_elem_Equal;

function asn1SccByteBuffer_Equal (val1, val2 :  asn1SccByteBuffer) return Boolean
is
    pragma Warnings (Off, "initialization of ret has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ret has no effect");
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := asn1SccByteBuffer_elem_Equal(val1.Data(i1), val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end asn1SccByteBuffer_Equal;

function asn1SccByteBuffer_elem_Init return asn1SccByteBuffer_elem
is
    val: asn1SccByteBuffer_elem;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccByteBuffer_elem_Init;
function asn1SccByteBuffer_Init return asn1SccByteBuffer
is
    val: asn1SccByteBuffer;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 65535 loop
        --  commented because it casues this warning    
        --  warning: condition can only be False if invalid values present
        pragma Loop_Invariant (i1 >=1 and i1<=65535);
        val.Data(i1) := asn1SccByteBuffer_elem_Init;
        i1 := i1 + 1;
    end loop;
    val.Length := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccByteBuffer_Init;

function asn1SccByteBuffer_IsConstraintValid(val : asn1SccByteBuffer) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
begin
    ret.Success := (val.Length <= 65535);
    ret.ErrorCode := (if ret.Success then 0 else ERR_BYTEBUFFER);
    if ret.Success then
        i1 := val.Data'First;
        while ret.Success and i1 <= val.Length loop
            pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
            ret.Success := (val.Data(i1) <= 255);
            if ret.Success then
                ret.Success := (val.Data(i1) <= 255);
            end if;
            ret.ErrorCode := (if ret.Success then 0 else ERR_BYTEBUFFER_ELM);
            i1 := i1+1;
        end loop;
    end if;
    return ret;
end asn1SccByteBuffer_IsConstraintValid;


pragma Warnings (On, "condition can only be False if invalid values present");
pragma Warnings (On, "condition can only be True if invalid values present");

 
end COM_N7SPACE_HWAS;